<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[[转]Kafka入门教程]]></title>
      <url>http://ehlxr.me/2016/10/10/%E8%BD%AC-Kafka%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/</url>
      <content type="text"><![CDATA[一、基本概念1. 介绍Kafka 是一个分布式的、可分区的、可复制的消息系统。它提供了普通消息系统的功能，但具有自己独特的设计。这个独特的设计是什么样的呢？ 首先让我们看几个基本的消息系统术语： Kafka 将消息以 topic 为单位进行归纳。 将向 Kafka topic 发布消息的程序成为 producers。 将预订 topics 并消费消息的程序成为 consumer。 Kafka 以集群的方式运行，可以由一个或多个服务组成，每个服务叫做一个 broker。 producers 通过网络将消息发送到 Kafka 集群，Kafka 集群向消费者提供消息，如下图所示： 客户端和服务端通过 TCP 协议通信。Kafka 提供了 Java 客户端，并且对多种语言都提供了支持。 2. Topics 和 Logs先来看一下 Kafka 提供的一个抽象概念：topic。一个 topic 是对一组消息的归纳。对每个 topic，Kafka 对它的日志进行了分区，如下图所示： 每个分区都由一系列有序的、不可变的消息组成，这些消息被连续的追加到分区中。分区中的每个消息都有一个连续的序列号叫做 offset，用来在分区中唯一的标识这个消息。 在一个可配置的时间段内，Kafka 集群保留所有发布的消息，不管这些消息有没有被消费。比如，如果消息的保存策略被设置为 2 天，那么在一个消息被发布的两天时间内，它都是可以被消费的。之后它将被丢弃以释放空间。Kafka 的性能是和数据量无关的常量级的，所以保留太多的数据并不是问题。 实际上每个 consumer 唯一需要维护的数据是消息在日志中的位置，也就是 offset。这个 offset 有 consumer 来维护：一般情况下随着 consumer 不断的读取消息，这 offset 的值不断增加，但其实 consumer 可以以任意的顺序读取消息，比如它可以将 offset 设置成为一个旧的值来重读之前的消息。 以上特点的结合，使 Kafka consumers 非常的轻量级：它们可以在不对集群和其他 consumer 造成影响的情况下读取消息。你可以使用命令行来 tail 消息而不会对其他正在消费消息的 consumer 造成影响。 将日志分区可以达到以下目的：首先这使得每个日志的数量不会太大，可以在单个服务上保存。另外每个分区可以单独发布和消费，为并发操作 topic 提供了一种可能。 3. 分布式每个分区在 Kafka 集群的若干服务中都有副本，这样这些持有副本的服务可以共同处理数据和请求，副本数量是可以配置的。副本使 Kafka 具备了容错能力。 每个分区都由一个服务器作为 leader，零或若干服务器作为 followers，leader 负责处理消息的读和写，followers 则去复制 leader。如果 leader down 了，followers 中的一台则会自动成为 leader。集群中的每个服务都会同时扮演两个角色：作为它所持有的一部分分区的 leader，同时作为其他分区的 followers，这样集群就会据有较好的负载均衡。 4. ProducersProducer 将消息发布到它指定的 topic 中,并负责决定发布到哪个分区。通常简单的由负载均衡机制随机选择分区，但也可以通过特定的分区函数选择分区。使用的更多的是第二种。 5. Consumers发布消息通常有两种模式：队列模式（queuing）和发布-订阅模式（publish-subscribe）。 队列模式中 consumers 可以同时从服务端读取消息，每个消息只被其中一个 consumer 读到。 发布-订阅模式中消息被广播到所有的 consumer 中。 Consumers 可以加入一个 consumer 组，共同竞争一个 topic，topic 中的消息将被分发到组中的一个成员中。同一组中的 consumer 可以在不同的程序中，也可以在不同的机器上。如果所有的 consumer 都在一个组中，这就成为了传统的队列模式，在各 consumer 中实现负载均衡。如果所有的 consumer 都不在不同的组中，这就成为了发布-订阅模式，所有的消息都被分发到所有的 consumer 中。更常见的是，每个 topic 都有若干数量的 consumer 组，每个组都是一个逻辑上的 “订阅者”，为了容错和更好的稳定性，每个组由若干 consumer 组成。这其实就是一个发布-订阅模式，只不过订阅者是个组而不是单个consumer。 相比传统的消息系统，Kafka 可以很好的保证有序性。传统的队列在服务器上保存有序的消息，如果多个 consumers 同时从这个服务器消费消息，服务器就会以消息存储的顺序向 consumer 分发消息。虽然服务器按顺序发布消息，但是消息是被异步的分发到各 consumer 上，所以当消息到达时可能已经失去了原来的顺序，这意味着并发消费将导致顺序错乱。为了避免故障，这样的消息系统通常使用 专用consumer 的概念，其实就是只允许一个消费者消费消息，当然这就意味着失去了并发性。 在这方面 Kafka 做的更好，通过分区的概念，Kafka 可以在多个 consumer 组并发的情况下提供较好的有序性和负载均衡。将每个分区分只分发给一个 consumer 组，这样一个分区就只被这个组的一个 consumer 消费，就可以顺序的消费这个分区的消息。因为有多个分区，依然可以在多个 consumer 组之间进行负载均衡。 注意： consumer 组的数量不能多于分区的数量，也就是有多少分区就允许多少并发消费。 Kafka 只能保证一个分区之内消息的有序性，在不同的分区之间是不可以的，这已经可以满足大部分应用的需求。如果需要 topic 中所有消息的有序性，那就只能让这个 topic 只有一个分区，当然也就只有一个 consumer 组消费它。 二、环境搭建Step 1：下载 Kafka点击下载最新的版本并解压。 12$ tar -zxvf kafka_2.11-0.10.0.1.tgz -C ~/apps$ cd kafka_2.11-0.10.0.1 Step 2：启动服务Kafka 用到了 Zookeeper，所有首先启动 Zookeeper，下面简单的启用一个单实例的 Zookkeeper 服务。可以在命令的结尾加个 &amp; 符号，这样就可以启动后离开控制台。 1234$ ./bin/zkServer.sh start ZooKeeper JMX enabled by defaultUsing config: /home/ehlxr/apps/zookeeper-3.4.9/bin/../conf/zoo.cfgStarting zookeeper ... STARTED 现在启动Kafka: 123$ bin/kafka-server-start.sh config/server.properties[2013-04-22 15:01:47,028] INFO Verifying properties (kafka.utils.VerifiableProperties)[2013-04-22 15:01:47,051] INFO Property socket.send.buffer.bytes is overridden to 1048576 (kafka.utils.VerifiableProperties) Step 3：创建 topic创建一个叫做 “test” 的 topic，它只有一个分区，一个副本。 1$ bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test 可以通过 list 命令查看创建的 topic： 12$ bin/kafka-topics.sh --list --zookeeper localhost:2181test 除了手动创建 topic，还可以配置 broker 让它自动创建 topic。 Step 4：发送消息Kafka 使用一个简单的命令行 producer，从文件中或者从标准输入中读取消息并发送到服务端。默认的每条命令将发送一条消息。 运行 producer 并在控制台中输一些消息，这些消息将被发送到服务端： 12$ bin/kafka-console-producer.sh --broker-list localhost:9092 --topic test This is a messageThis is another message ctrl+c 可以退出发送。 Step 5：启动 consumerKafka 也有一个命令行 consumer 可以读取消息并输出到标准输出： 123$ bin/kafka-console-consumer.sh --zookeeper localhost:2181 --topic test --from-beginningThis is a messageThis is another message 你在一个终端中运行 consumer 命令行，另一个终端中运行 producer 命令行，就可以在一个终端输入消息，另一个终端读取消息。 这两个命令都有自己的可选参数，可以在运行的时候不加任何参数可以看到帮助信息。 Step 6：搭建一个多个 broker 的集群刚才只是启动了单个 broker，现在启动有 3 个 broker 组成的集群，这些 broker 节点也都是在本机上的。 首先为每个节点编写配置文件： 12$ cp config/server.properties config/server-1.properties$ cp config/server.properties config/server-2.properties 在拷贝出的新文件中添加以下参数： 1234config/server-1.properties: broker.id=1 port=9093 log.dir=/tmp/kafka-logs-1 1234config/server-2.properties: broker.id=2 port=9094 log.dir=/tmp/kafka-logs-2 broker.id 在集群中唯一的标注一个节点，因为在同一个机器上，所以必须制定不同的端口和日志文件，避免数据被覆盖。 刚才已经启动可 Zookeeper 和一个节点，现在启动另外两个节点： 123$ bin/kafka-server-start.sh config/server-1.properties &amp;$ bin/kafka-server-start.sh config/server-2.properties &amp; 创建一个拥有 3 个副本的 topic： 1$ bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 3 --partitions 1 --topic my-replicated-topic 现在我们搭建了一个集群，怎么知道每个节点的信息呢？运行 describe topics 命令就可以了： 1$ bin/kafka-topics.sh --describe --zookeeper localhost:2181 --topic my-replicated-topic 下面解释一下这些输出。第一行是对所有分区的一个描述，然后每个分区都会对应一行，因为我们只有一个分区所以下面就只加了一行。 leader：负责处理消息的读和写，leader是从所有节点中随机选择的。 replicas：列出了所有的副本节点，不管节点是否在服务中。 isr：是正在服务中的节点。 在我们的例子中，节点 1 是作为 leader 运行。 向 topic 发送消息： 1$ bin/kafka-console-producer.sh --broker-list localhost:9092 --topic my-replicated-topic 1my test message 1my test message 2 消费这些消息： 1$ bin/kafka-console-consumer.sh --zookeeper localhost:2181 --from-beginning --topic my-replicated-topic 12my test message 1my test message 2 测试一下容错能力，Broker 1 作为 leader 运行，现在我们 kill 掉它： 12$ ps | grep server-1.properties7564 ttys002 0:15.91 /System/Library/Frameworks/JavaVM.framework/Versions/1.6/Home/bin/java...$ kill -9 7564 另外一个节点被选做了 leader，node 1 不再出现在 in-sync 副本列表中： 1234$ bin/kafka-topics.sh --describe --zookeeper localhost:218192 --topic my-replicated-topicTopic:my-replicated-topic PartitionCount:1 ReplicationFactor:3 Configs:Topic: my-replicated-topic Partition: 0 Leader: 2 Replicas: 1,2,0 Isr: 2,0 虽然最初负责续写消息的 leader down 掉了，但之前的消息还是可以消费的： 1234$ bin/kafka-console-consumer.sh --zookeeper localhost:2181 --from-beginning --topic my-replicated-topic...my test message 1my test message 2 看来 Kafka 的容错机制还是不错的。 三、搭建Kafka开发环境我们搭建了 kafka 的服务器，并可以使用 Kafka 的命令行工具创建 topic，发送和接收消息。下面我们来搭建 kafka 的开发环境。 1. 添加依赖搭建开发环境需要引入 kafka 的 jar 包，一种方式是将 Kafka 安装包中 lib 下的 jar 包加入到项目的 classpath 中，这种比较简单了。不过我们使用另一种更加流行的方式：使用 maven 管理 jar 包依赖。 创建好 maven 项目后，在 pom.xml 中添加以下依赖： 12345&lt;dependency&gt; &lt;groupId&gt; org.apache.kafka&lt;/groupId &gt; &lt;artifactId&gt; kafka_2.10&lt;/artifactId &gt; &lt;version&gt; 0.8.0&lt;/ version&gt;&lt;/dependency&gt; 添加依赖后你会发现有两个 jar 包的依赖找不到。没关系我都帮你想好了，点击这里下载这两个 jar 包，解压后你有两种选择，第一种是使用 mvn 的 install 命令将 jar 包安装到本地仓库，另一种是直接将解压后的文件夹拷贝到 mvn 本地仓库的 com 文件夹下，比如我的本地仓库是 d:\mvn，完成后我的目录结构是这样的： 2. 配置程序首先是一个充当配置文件作用的接口,配置了 Kafka 的各种连接参数： 123456789101112131415package com.sohu.kafkademon;public interface KafkaProperties &#123; final static String zkConnect = "10.22.10.139:2181"; final static String groupId = "group1"; final static String topic = "topic1"; final static String kafkaServerURL = "10.22.10.139"; final static int kafkaServerPort = 9092; final static int kafkaProducerBufferSize = 64 * 1024; final static int connectionTimeOut = 20000; final static int reconnectInterval = 10000; final static String topic2 = "topic2"; final static String topic3 = "topic3"; final static String clientId = "SimpleConsumerDemoClient";&#125; 3. Producer123456789101112131415161718192021222324252627282930313233package com.sohu.kafkademon;import java.util.Properties;import kafka.producer.KeyedMessage;import kafka.producer.ProducerConfig;public class KafkaProducer extends Thread &#123; private final kafka.javaapi.producer.Producer&lt;Integer, String&gt; producer; private final String topic; private final Properties props = new Properties(); public KafkaProducer(String topic) &#123; props.put("serializer.class", "kafka.serializer.StringEncoder"); props.put("metadata.broker.list", "10.22.10.139:9092"); producer = new kafka.javaapi.producer.Producer&lt;Integer, String&gt;(new ProducerConfig(props)); this.topic = topic; &#125; @Override public void run() &#123; int messageNo = 1; while (true) &#123; String messageStr = new String("Message_" + messageNo); System.out.println("Send:" + messageStr); producer.send(new KeyedMessage&lt;Integer, String&gt;(topic, messageStr)); messageNo++; try &#123; sleep(3000); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;&#125; 4. Consumer123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.sohu.kafkademon;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.Properties;import kafka.consumer.ConsumerConfig;import kafka.consumer.ConsumerIterator;import kafka.consumer.KafkaStream;import kafka.javaapi.consumer.ConsumerConnector;public class KafkaConsumer extends Thread &#123; private final ConsumerConnector consumer; private final String topic; public KafkaConsumer(String topic) &#123; consumer = kafka.consumer.Consumer.createJavaConsumerConnector( createConsumerConfig()); this.topic = topic; &#125; private static ConsumerConfig createConsumerConfig() &#123; Properties props = new Properties(); props.put("zookeeper.connect", KafkaProperties.zkConnect); props.put("group.id", KafkaProperties.groupId); props.put("zookeeper.session.timeout.ms", "40000"); props.put("zookeeper.sync.time.ms", "200"); props.put("auto.commit.interval.ms", "1000"); return new ConsumerConfig(props); &#125; @Override public void run() &#123; Map&lt;String, Integer&gt; topicCountMap = new HashMap&lt;String, Integer&gt;(); topicCountMap.put(topic, new Integer(1)); Map&lt;String, List&lt;KafkaStream&lt;byte[], byte[]&gt;&gt;&gt; consumerMap = consumer.createMessageStreams(topicCountMap); KafkaStream&lt;byte[], byte[]&gt; stream = consumerMap.get(topic).get(0); ConsumerIterator&lt;byte[], byte[]&gt; it = stream.iterator(); while (it.hasNext()) &#123; System.out.println("receive：" + new String(it.next().message())); try &#123; sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 5. 简单的发送接收运行下面这个程序，就可以进行简单的发送接收消息了： 1234567891011package com.sohu.kafkademon;public class KafkaConsumerProducerDemo &#123; public static void main(String[] args) &#123; KafkaProducer producerThread = new KafkaProducer(KafkaProperties.topic); producerThread.start(); KafkaConsumer consumerThread = new KafkaConsumer(KafkaProperties.topic); consumerThread.start(); &#125;&#125; 6. 高级别的consumer下面是比较负载的发送接收的程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.sohu.kafkademon;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.Properties;import kafka.consumer.ConsumerConfig;import kafka.consumer.ConsumerIterator;import kafka.consumer.KafkaStream;import kafka.javaapi.consumer.ConsumerConnector;public class KafkaConsumer extends Thread &#123; private final ConsumerConnector consumer; private final String topic; public KafkaConsumer(String topic) &#123; consumer = kafka.consumer.Consumer.createJavaConsumerConnector( createConsumerConfig()); this.topic = topic; &#125; private static ConsumerConfig createConsumerConfig() &#123; Properties props = new Properties(); props.put("zookeeper.connect", KafkaProperties.zkConnect); props.put("group.id", KafkaProperties.groupId); props.put("zookeeper.session.timeout.ms", "40000"); props.put("zookeeper.sync.time.ms", "200"); props.put("auto.commit.interval.ms", "1000"); return new ConsumerConfig(props); &#125; @Override public void run() &#123; Map&lt;String, Integer&gt; topicCountMap = new HashMap&lt;String, Integer&gt;(); topicCountMap.put(topic, new Integer(1)); Map&lt;String, List&lt;KafkaStream&lt;byte[], byte[]&gt;&gt;&gt; consumerMap = consumer.createMessageStreams(topicCountMap); KafkaStream&lt;byte[], byte[]&gt; stream = consumerMap.get(topic).get(0); ConsumerIterator&lt;byte[], byte[]&gt; it = stream.iterator(); while (it.hasNext()) &#123; System.out.println("receive：" + new String(it.next().message())); try &#123; sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 四、数据持久化1. 不要畏惧文件系统!Kafka 大量依赖文件系统去存储和缓存消息。对于硬盘有个传统的观念是硬盘总是很慢，这使很多人怀疑基于文件系统的架构能否提供优异的性能。实际上硬盘的快慢完全取决于使用它的方式。设计良好的硬盘架构可以和内存一样快。 在 6 块 7200 转的 SATA RAID-5 磁盘阵列的线性写速度差不多是 600MB/s，但是随即写的速度却是 100k/s，差了差不多6000倍。现代的操作系统都对次做了大量的优化，使用了 read-ahead 和 write-behind 的技巧，读取的时候成块的预读取数据，写的时候将各种微小琐碎的逻辑写入组织合并成一次较大的物理写入。对此的深入讨论可以查看这里，它们发现线性的访问磁盘，很多时候比随机的内存访问快得多。 为了提高性能，现代操作系统往往使用内存作为磁盘的缓存，现代操作系统乐于把所有空闲内存用作磁盘缓存，虽然这可能在缓存回收和重新分配时牺牲一些性能。所有的磁盘读写操作都会经过这个缓存，这不太可能被绕开除非直接使用 I/O。所以虽然每个程序都在自己的线程里只缓存了一份数据，但在操作系统的缓存里还有一份，这等于存了两份数据。 另外再来讨论一下 JVM，以下两个事实是众所周知的： Java对象占用空间是非常大的，差不多是要存储的数据的两倍甚至更高。 随着堆中数据量的增加，垃圾回收回变的越来越困难。 基于以上分析，如果把数据缓存在内存里，因为需要存储两份，不得不使用两倍的内存空间，Kafka 基于 JVM，又不得不将空间再次加倍,再加上要避免 GC 带来的性能影响，在一个 32G 内存的机器上，不得不使用到 28-30G 的内存空间。并且当系统重启的时候，又必须要将数据刷到内存中（10GB 内存差不多要用10分钟），就算使用冷刷新（不是一次性刷进内存，而是在使用数据的时候没有就刷到内存）也会导致最初的时候新能非常慢。但是使用文件系统，即使系统重启了，也不需要刷新数据。使用文件系统也简化了维护数据一致性的逻辑。 所以与传统的将数据缓存在内存中然后刷到硬盘的设计不同，Kafka 直接将数据写到了文件系统的日志中。 2. 常量时间的操作效率在大多数的消息系统中，数据持久化的机制往往是为每个 cosumer 提供一个 B 树或者其他的随机读写的数据结构。B 树当然是很棒的，但是也带了一些代价：比如 B 树的复杂度是 O(log N)，O(log N) 通常被认为就是常量复杂度了，但对于硬盘操作来说并非如此。磁盘进行一次搜索需要 10ms，每个硬盘在同一时间只能进行一次搜索，这样并发处理就成了问题。虽然存储系统使用缓存进行了大量优化，但是对于树结构的性能的观察结果却表明，它的性能往往随着数据的增长而线性下降，数据增长一倍，速度就会降低一倍。 直观的讲，对于主要用于日志处理的消息系统，数据的持久化可以简单的通过将数据追加到文件中实现，读的时候从文件中读就好了。这样做的好处是读和写都是 O(1) 的，并且读操作不会阻塞写操作和其他操作。这样带来的性能优势是很明显的，因为性能和数据的大小没有关系了。 既然可以使用几乎没有容量限制（相对于内存来说）的硬盘空间建立消息系统，就可以在没有性能损失的情况下提供一些一般消息系统不具备的特性。比如，一般的消息系统都是在消息被消费后立即删除，Kafka 却可以将消息保存一段时间（比如一星期），这给 consumer 提供了很好的机动性和灵活性，这点在今后的文章中会有详述。 五、消息传输的事务定义之前讨论了 consumer 和 producer 是怎么工作的，现在来讨论一下数据传输方面。数据传输的事务定义通常有以下三种级别： 最多一次: 消息不会被重复发送，最多被传输一次，但也有可能一次不传输。 最少一次: 消息不会被漏发送，最少被传输一次，但也有可能被重复传输。 精确的一次（Exactly once）: 不会漏传输也不会重复传输,每个消息都传输被一次而且仅仅被传输一次，这是大家所期望的。 大多数消息系统声称可以做到 “精确的一次”，但是仔细阅读它们的的文档可以看到里面存在误导，比如没有说明当 consumer 或 producer 失败时怎么样，或者当有多个 consumer 并行时怎么样，或写入硬盘的数据丢失时又会怎么样。kafka 的做法要更先进一些。当发布消息时，Kafka 有一个 “committed” 的概念，一旦消息被提交了，只要消息被写入的分区的所在的副本 broker 是活动的，数据就不会丢失。关于副本的活动的概念，下节文档会讨论。现在假设 broker 是不会 down 的。 如果 producer 发布消息时发生了网络错误，但又不确定实在提交之前发生的还是提交之后发生的，这种情况虽然不常见，但是必须考虑进去，现在 Kafka 版本还没有解决这个问题，将来的版本正在努力尝试解决。 并不是所有的情况都需要 “精确的一次” 这样高的级别，Kafka 允许 producer 灵活的指定级别。比如 producer 可以指定必须等待消息被提交的通知，或者完全的异步发送消息而不等待任何通知，或者仅仅等待 leader 声明它拿到了消息（followers 没有必要）。 现在从 consumer 的方面考虑这个问题，所有的副本都有相同的日志文件和相同的 offset，consumer 维护自己消费的消息的 offset，如果 consumer 不会崩溃当然可以在内存中保存这个值，当然谁也不能保证这点。如果 consumer 崩溃了，会有另外一个 consumer 接着消费消息，它需要从一个合适的 offset 继续处理。这种情况下可以有以下选择： consumer 可以先读取消息，然后将 offset 写入日志文件中，然后再处理消息。这存在一种可能就是在存储 offset 后还没处理消息就 crash 了，新的 consumer 继续从这个 offset 处理，那么就会有些消息永远不会被处理，这就是上面说的 “最多一次”。 consumer 可以先读取消息，处理消息，最后记录 offset，当然如果在记录 offset 之前就 crash 了，新的 consumer 会重复的消费一些消息，这就是上面说的 “最少一次”。 “精确一次” 可以通过将提交分为两个阶段来解决：保存了 offset 后提交一次，消息处理成功之后再提交一次。但是还有个更简单的做法：将消息的 offset 和消息被处理后的结果保存在一起。比如用 Hadoop ETL 处理消息时，将处理后的结果和 offset 同时保存在 HDFS 中，这样就能保证消息和 offser 同时被处理了。 六、性能优化Kafka 在提高效率方面做了很大努力。Kafka 的一个主要使用场景是处理网站活动日志，吞吐量是非常大的，每个页面都会产生好多次写操作。读方面，假设每个消息只被消费一次，读的量的也是很大的，Kafka 也尽量使读的操作更轻量化。 我们之前讨论了磁盘的性能问题，线性读写的情况下影响磁盘性能问题大约有两个方面：太多的琐碎的 I/O 操作和太多的字节拷贝。I/O 问题发生在客户端和服务端之间，也发生在服务端内部的持久化的操作中。 1. 消息集（message set）为了避免这些问题，Kafka 建立了 “消息集（message set）” 的概念，将消息组织到一起，作为处理的单位。以消息集为单位处理消息，比以单个的消息为单位处理，会提升不少性能。Producer 把消息集一块发送给服务端，而不是一条条的发送；服务端把消息集一次性的追加到日志文件中，这样减少了琐碎的 I/O 操作。consumer 也可以一次性的请求一个消息集。 另外一个性能优化是在字节拷贝方面。在低负载的情况下这不是问题，但是在高负载的情况下它的影响还是很大的。为了避免这个问题，Kafka 使用了标准的二进制消息格式，这个格式可以在 producer，broker 和 producer 之间共享而无需做任何改动。 2. Zero CopyBroker 维护的消息日志仅仅是一些目录文件，消息集以固定队的格式写入到日志文件中，这个格式 producer 和 consumer 是共享的，这使得 Kafka 可以一个很重要的点进行优化：消息在网络上的传递。现代的 unix 操作系统提供了高性能的将数据从页面缓存发送到 socket 的系统函数，在 linux 中，这个函数是 sendfile。 为了更好的理解 sendfile 的好处，我们先来看下一般将数据从文件发送到 socket 的数据流向： 操作系统把数据从文件拷贝内核中的页缓存中 应用程序从页缓存从把数据拷贝自己的内存缓存中 应用程序将数据写入到内核中 socket 缓存中操作系统把数据从 socket 缓存中拷贝到网卡接口缓存，从这里发送到网络上。 这显然是低效率的，有 4 次拷贝和 2 次系统调用。Sendfile 通过直接将数据从页面缓存发送网卡接口缓存，避免了重复拷贝，大大的优化了性能。 在一个多 consumers 的场景里，数据仅仅被拷贝到页面缓存一次而不是每次消费消息的时候都重复的进行拷贝。这使得消息以近乎网络带宽的速率发送出去。这样在磁盘层面你几乎看不到任何的读操作，因为数据都是从页面缓存中直接发送到网络上去了。 这篇文章详细介绍了 sendfile 和 zero-copy 技术在 Java 方面的应用。 3. 数据压缩很多时候，性能的瓶颈并非 CPU 或者硬盘而是网络带宽，对于需要在数据中心之间传送大量数据的应用更是如此。当然用户可以在没有 Kafka 支持的情况下各自压缩自己的消息，但是这将导致较低的压缩率，因为相比于将消息单独压缩，将大量文件压缩在一起才能起到最好的压缩效果。 Kafka 采用了端到端的压缩：因为有 “消息集” 的概念，客户端的消息可以一起被压缩后送到服务端，并以压缩后的格式写入日志文件，以压缩的格式发送到 consumer，消息从 producer 发出到 consumer 拿到都被是压缩的，只有在 consumer 使用的时候才被解压缩，所以叫做 “端到端的压缩”。 Kafka 支持 GZIP 和 Snappy 压缩协议。更详细的内容可以查看这里。 七、Producer 和 Consumer1. Kafka Producer 消息发送producer 直接将数据发送到 broker 的 leader（主节点），不需要在多个节点进行分发。为了帮助 producer 做到这点，所有的 Kafka 节点都可以及时的告知：哪些节点是活动的，目标 topic 目标分区的 leader 在哪。这样 producer 就可以直接将消息发送到目的地了。 客户端控制消息将被分发到哪个分区。可以通过负载均衡随机的选择，或者使用分区函数。Kafka 允许用户实现分区函数，指定分区的 key，将消息 hash 到不同的分区上（当然有需要的话，也可以覆盖这个分区函数自己实现逻辑）。比如如果你指定的 key 是 user id，那么同一个用户发送的消息都被发送到同一个分区上。经过分区之后，consumer 就可以有目的的消费某个分区的消息。 2. 异步发送批量发送可以很有效的提高发送效率。Kafka producer 的异步发送模式允许进行批量发送，先将消息缓存在内存中，然后一次请求批量发送出去。这个策略可以配置的，比如可以指定缓存的消息达到某个量的时候就发出去，或者缓存了固定的时间后就发送出去（比如 100 条消息就发送，或者每 5 秒发送一次）。这种策略将大大减少服务端的 I/O 次数。 既然缓存是在 producer 端进行的，那么当 producer 崩溃时，这些消息就会丢失。Kafka 0.8.1 的异步发送模式还不支持回调，就不能在发送出错时进行处理。Kafka 0.9 可能会增加这样的回调函数。见 Proposed Producer API。 3. Kafka ConsumerKafa consumer 消费消息时，向broker发出 fetch 请求去消费特定分区的消息。consumer 指定消息在日志中的偏移量（offset），就可以消费从这个位置开始的消息。customer 拥有了 offset 的控制权，可以向后回滚去重新消费之前的消息，这是很有意义的。 4. 推还是拉？Kafka 最初考虑的问题是，customer 应该从 brokes 拉取消息还是 brokers 将消息推送到 consumer，也就是 pull 还 push。在这方面，Kafka 遵循了一种大部分消息系统共同的传统的设计：producer 将消息推送到 broker，consumer 从 broker 拉取消息。 一些消息系统比如 Scribe 和 Apache Flume 采用了push 模式，将消息推送到下游的 consumer。这样做有好处也有坏处：由 broker 决定消息推送的速率，对于不同消费速率的 consumer 就不太好处理了。消息系统都致力于让 consumer 以最大的速率最快速的消费消息，但不幸的是，push 模式下，当 broker 推送的速率远大于 consumer 消费的速率时，consumer 恐怕就要崩溃了。最终 Kafka 还是选取了传统的 pull 模式。 Pull 模式的另外一个好处是 consumer 可以自主决定是否批量的从 broker 拉取数据。Push 模式必须在不知道下游 consumer 消费能力和消费策略的情况下决定是立即推送每条消息还是缓存之后批量推送。如果为了避免 consumer 崩溃而采用较低的推送速率，将可能导致一次只推送较少的消息而造成浪费。Pull 模式下，consumer 就可以根据自己的消费能力去决定这些策略。 Pull 有个缺点是，如果 broker 没有可供消费的消息，将导致 consumer 不断在循环中轮询，直到新消息到 t 达。为了避免这点，Kafka 有个参数可以让 consumer 阻塞知道新消息到达（当然也可以阻塞知道消息的数量达到某个特定的量这样就可以批量发送）。 5. 消费状态跟踪对消费消息状态的记录也是很重要的。 大部分消息系统在 broker 端的维护消息被消费的记录：一个消息被分发到 consumer 后 broker 就马上进行标记或者等待 customer 的通知后进行标记。这样也可以在消息在消费后立马就删除以减少空间占用。 但是这样会不会有什么问题呢？如果一条消息发送出去之后就立即被标记为消费过的，一旦 consumer 处理消息时失败了（比如程序崩溃）消息就丢失了。为了解决这个问题，很多消息系统提供了另外一个个功能：当消息被发送出去之后仅仅被标记为已发送状态，当接到 consumer 已经消费成功的通知后才标记为已被消费的状态。这虽然解决了消息丢失的问题，但产生了新问题，首先如果 consumer 处理消息成功了但是向 broker 发送响应时失败了，这条消息将被消费两次。第二个问题时，broker 必须维护每条消息的状态，并且每次都要先锁住消息然后更改状态然后释放锁。这样麻烦又来了，且不说要维护大量的状态数据，比如如果消息发送出去但没有收到消费成功的通知，这条消息将一直处于被锁定的状态，Kafka 采用了不同的策略。Topic 被分成了若干分区，每个分区在同一时间只被一个 consumer 消费。这意味着每个分区被消费的消息在日志中的位置仅仅是一个简单的整数：offset。这样就很容易标记每个分区消费状态就很容易了，仅仅需要一个整数而已。这样消费状态的跟踪就很简单了。 这带来了另外一个好处：consumer 可以把 offset 调成一个较老的值，去重新消费老的消息。这对传统的消息系统来说看起来有些不可思议，但确实是非常有用的，谁规定了一条消息只能被消费一次呢？consumer发现解析数据的程序有 bug，在修改 bug 后再来解析一次消息，看起来是很合理的额呀！ 6. 离线处理消息高级的数据持久化允许 consumer 每个隔一段时间批量的将数据加载到线下系统中比如 Hadoop 或者数据仓库。这种情况下，Hadoop 可以将加载任务分拆，拆成每个 broker 或每个 topic 或每个分区一个加载任务。Hadoop 具有任务管理功能，当一个任务失败了就可以重启而不用担心数据被重新加载，只要从上次加载的位置继续加载消息就可以了。 八、主从同步Kafka 允许 topic 的分区拥有若干副本，这个数量是可以配置的，你可以为每个 topic 配置副本的数量。Kafka 会自动在每个个副本上备份数据，所以当一个节点 down 掉时数据依然是可用的。 Kafka 的副本功能不是必须的，你可以配置只有一个副本，这样其实就相当于只有一份数据。 创建副本的单位是 topic 的分区，每个分区都有一个 leader 和零或多个 followers。所有的读写操作都由 leader 处理，一般分区的数量都比 broker 的数量多的多，各分区的 leader 均匀的分布在 brokers 中。所有的 followers 都复制 leader 的日志，日志中的消息和顺序都和 leader 中的一致。flowers 向普通的 consumer 那样从 leader 那里拉取消息并保存在自己的日志文件中。 许多分布式的消息系统自动的处理失败的请求，它们对一个节点是否存活着（alive）有着清晰的定义。Kafka 判断一个节点是否活着有两个条件： 节点必须可以维护和 ZooKeeper 的连接，Zookeeper 通过心跳机制检查每个节点的连接。 如果节点是个 follower，他必须能及时的同步 leader 的写操作，延时不能太久。 符合以上条件的节点准确的说应该是“同步中的（in sync）”，而不是模糊的说是 “活着的” 或是 “失败的”。Leader 会追踪所有 “同步中” 的节点，一旦一个 down 掉了，或是卡住了，或是延时太久，leader 就会把它移除。至于延时多久算是 “太久”，是由参数 replica.lag.max.messages 决定的，怎样算是卡住了，怎是由参数 replica.lag.time.max.ms 决定的。 只有当消息被所有的副本加入到日志中时，才算是 “committed”，只有 committed 的消息才会发送给 consumer，这样就不用担心一旦 leader down 掉了消息会丢失。Producer 也可以选择是否等待消息被提交的通知，这个是由参数 request.required.acks 决定的。 Kafka 保证只要有一个 “同步中” 的节点，“committed” 的消息就不会丢失。 1. Leader的选择Kafka 的核心是日志文件，日志文件在集群中的同步是分布式数据系统最基础的要素。 如果leaders永远不会down的话我们就不需要followers了！一旦leader down掉了，需要在followers中选择一个新的leader.但是followers本身有可能延时太久或者crash，所以必须选择高质量的follower作为leader.必须保证，一旦一个消息被提交了，但是leader down掉了，新选出的leader必须可以提供这条消息。大部分的分布式系统采用了多数投票法则选择新的leader,对于多数投票法则，就是根据所有副本节点的状况动态的选择最适合的作为leader.Kafka并不是使用这种方法。 Kafaka动态维护了一个同步状态的副本的集合（a set of in-sync replicas），简称ISR，在这个集合中的节点都是和leader保持高度一致的，任何一条消息必须被这个集合中的每个节点读取并追加到日志中了，才回通知外部这个消息已经被提交了。因此这个集合中的任何一个节点随时都可以被选为leader.ISR在ZooKeeper中维护。ISR中有f+1个节点，就可以允许在f个节点down掉的情况下不会丢失消息并正常提供服。ISR的成员是动态的，如果一个节点被淘汰了，当它重新达到“同步中”的状态时，他可以重新加入ISR.这种leader的选择方式是非常快速的，适合kafka的应用场景。 一个邪恶的想法：如果所有节点都down掉了怎么办？Kafka对于数据不会丢失的保证，是基于至少一个节点是存活的，一旦所有节点都down了，这个就不能保证了。实际应用中，当所有的副本都down掉时，必须及时作出反应。可以有以下两种选择: 等待ISR中的任何一个节点恢复并担任leader。 选择所有节点中（不只是ISR）第一个恢复的节点作为leader. 这是一个在可用性和连续性之间的权衡。如果等待ISR中的节点恢复，一旦ISR中的节点起不起来或者数据都是了，那集群就永远恢复不了了。如果等待ISR意外的节点恢复，这个节点的数据就会被作为线上数据，有可能和真实的数据有所出入，因为有些数据它可能还没同步到。Kafka目前选择了第二种策略，在未来的版本中将使这个策略的选择可配置，可以根据场景灵活的选择。这种窘境不只Kafka会遇到，几乎所有的分布式数据系统都会遇到。 2. 副本管理以上仅仅以一个topic一个分区为例子进行了讨论，但实际上一个Kafka将会管理成千上万的topic分区.Kafka尽量的使所有分区均匀的分布到集群所有的节点上而不是集中在某些节点上，另外主从关系也尽量均衡这样每个几点都会担任一定比例的分区的leader。 优化leader的选择过程也是很重要的，它决定了系统发生故障时的空窗期有多久。Kafka选择一个节点作为“controller”,当发现有节点down掉的时候它负责在游泳分区的所有节点中选择新的leader,这使得Kafka可以批量的高效的管理所有分区节点的主从关系。如果controller down掉了，活着的节点中的一个会备切换为新的controller. 九、客户端API1. Kafka Producer APIsKafka Procuder API 有两种，它们分别是：kafka.producer.SyncProducer 和 kafka.producer.async.AsyncProducer。它们都实现了同一个接口： 12345678910class Producer &#123; /* 将消息发送到指定分区 */ publicvoid send(kafka.javaapi.producer.ProducerData&lt;K,V&gt; producerData); /* 批量发送一批消息 */ publicvoid send(java.util.List&lt;kafka.javaapi.producer.ProducerData&lt;K,V&gt;&gt; producerData); /* 关闭producer */ publicvoid close();&#125; Producer API提供了以下功能： 可以将多个消息缓存到本地队列里，然后异步的批量发送到broker，可以通过参数producer.type=async做到。缓存的大小可以通过一些参数指定：queue.time和batch.size。一个后台线程（(kafka.producer.async.ProducerSendThread）从队列中取出数据并让kafka.producer.EventHandler将消息发送到broker，也可以通过参数event.handler定制handler，在producer端处理数据的不同的阶段注册处理器，比如可以对这一过程进行日志追踪，或进行一些监控。只需实现kafka.producer.async.CallbackHandler接口，并在callback.handler中配置。 自己编写Encoder来序列化消息，只需实现下面这个接口。默认的Encoder是kafka.serializer.DefaultEncoder。 123interface Encoder&lt;T&gt; &#123; public Message toMessage(T data);&#125; 提供了基于Zookeeper的broker自动感知能力，可以通过参数zk.connect实现。如果不使用Zookeeper，也可以使用broker.list参数指定一个静态的brokers列表，这样消息将被随机的发送到一个broker上，一旦选中的broker失败了，消息发送也就失败了。 通过分区函数kafka.producer.Partitioner类对消息分区。 123interface Partitioner&lt;T&gt; &#123; int partition(T key, int numPartitions);&#125; 分区函数有两个参数：key和可用的分区数量，从分区列表中选择一个分区并返回id。默认的分区策略是hash(key)%numPartitions.如果key是null,就随机的选择一个。可以通过参数partitioner.class定制分区函数。 2. KafKa Consumer APIsConsumer API有两个级别。低级别的和一个指定的broker保持连接，并在接收完消息后关闭连接，这个级别是无状态的，每次读取消息都带着offset。 高级别的API隐藏了和brokers连接的细节，在不必关心服务端架构的情况下和服务端通信。还可以自己维护消费状态，并可以通过一些条件指定订阅特定的topic,比如白名单黑名单或者正则表达式。 2.1 低级别的API123456789101112131415class SimpleConsumer &#123; /*向一个broker发送读取请求并得到消息集 */ public ByteBufferMessageSet fetch(FetchRequest request); /*向一个broker发送读取请求并得到一个相应集 */ public MultiFetchResponse multifetch(List&lt;FetchRequest&gt; fetches); /** * 得到指定时间之前的offsets * 返回值是offsets列表，以倒序排序 * @param time: 时间，毫秒, * 如果指定为OffsetRequest$.MODULE$.LATIEST_TIME(), 得到最新的offset. * 如果指定为OffsetRequest$.MODULE$.EARLIEST_TIME(),得到最老的offset. */ publiclong[] getOffsetsBefore(String topic, int partition, long time, int maxNumOffsets);&#125; 低级别的API是高级别API实现的基础，也是为了一些对维持消费状态有特殊需求的场景，比如Hadoop consumer这样的离线consumer。 2.2 高级别的API123456789101112131415161718192021222324/* 创建连接 */ConsumerConnector connector = Consumer.create(consumerConfig);interface ConsumerConnector &#123;/*** 这个方法可以得到一个流的列表，每个流都是MessageAndMetadata的迭代，* 通过MessageAndMetadata可以拿到消息和其他的元数据（目前之后topic）* Input: a map of &lt;topic, #streams&gt;* Output: a map of &lt;topic, list of message streams&gt;*/public Map&lt;String,List&lt;KafkaStream&gt;&gt; createMessageStreams(Map&lt;String,Int&gt; topicCountMap);/*** 你也可以得到一个流的列表，它包含了符合TopicFiler的消息的迭代，* 一个TopicFilter是一个封装了白名单或黑名单的正则表达式。*/public List&lt;KafkaStream&gt; createMessageStreamsByFilter( TopicFilter topicFilter, int numStreams); /* 提交目前消费到的offset */ public commitOffsets() /* 关闭连接 */ public shutdown()&#125; 这个API围绕着由KafkaStream实现的迭代器展开，每个流代表一系列从一个或多个分区多和broker上汇聚来的消息，每个流由一个线程处理，所以客户端可以在创建的时候通过参数指定想要几个流。一个流是多个分区多个broker的合并，但是每个分区的消息只会流向一个流。 每调用一次createMessageStreams都会将consumer注册到topic上，这样consumer和brokers之间的负载均衡就会进行调整。API鼓励每次调用创建更多的topic流以减少这种调整。createMessageStreamsByFilter方法注册监听可以感知新的符合filter的tipic。 十、消息和日志消息由一个固定长度的头部和可变长度的字节数组组成。头部包含了一个版本号和CRC32校验码。 1234567891011121314/*** 具有N个字节的消息的格式如下* 如果版本号是0* 1. 1个字节的 "magic" 标记* 2. 4个字节的CRC32校验码* 3. N - 5个字节的具体信息** 如果版本号是1* 1. 1个字节的 "magic" 标记* 2.1个字节的参数允许标注一些附加的信息比如是否压缩了，解码类型等* 3.4个字节的CRC32校验码* 4. N - 6 个字节的具体信息*/ 1. 日志一个叫做“my_topic”且有两个分区的的topic,它的日志有两个文件夹组成，my_topic_0和my_topic_1,每个文件夹里放着具体的数据文件，每个数据文件都是一系列的日志实体，每个日志实体有一个4个字节的整数N标注消息的长度，后边跟着N个字节的消息。每个消息都可以由一个64位的整数offset标注，offset标注了这条消息在发送到这个分区的消息流中的起始位置。每个日志文件的名称都是这个文件第一条日志的offset.所以第一个日志文件的名字就是00000000000.kafka.所以每相邻的两个文件名字的差就是一个数字S,S差不多就是配置文件中指定的日志文件的最大容量。 消息的格式都由一个统一的接口维护，所以消息可以在producer,broker和consumer之间无缝的传递。存储在硬盘上的消息格式如下所示： 消息长度: 4 bytes (value: 1+4+n) 版本号: 1 byte CRC校验码: 4 bytes 具体的消息: n bytes 2. 写操作消息被不断的追加到最后一个日志的末尾，当日志的大小达到一个指定的值时就会产生一个新的文件。对于写操作有两个参数，一个规定了消息的数量达到这个值时必须将数据刷新到硬盘上，另外一个规定了刷新到硬盘的时间间隔，这对数据的持久性是个保证，在系统崩溃的时候只会丢失一定数量的消息或者一个时间段的消息。 3. 读操作需要两个参数：一个64位的offset和一个S字节的最大读取量。S通常比单个消息的大小要大，但在一些个别消息比较大的情况下，S会小于单个消息的大小。这种情况下读操作会不断重试，每次重试都会将读取量加倍，直到读取到一个完整的消息。可以配置单个消息的最大值，这样服务器就会拒绝大小超过这个值的消息。也可以给客户端指定一个尝试读取的最大上限，避免为了读到一个完整的消息而无限次的重试。 在实际执行读取操纵时，首先需要定位数据所在的日志文件，然后根据offset计算出在这个日志中的offset(前面的的offset是整个分区的offset),然后在这个offset的位置进行读取。定位操作是由二分查找法完成的，Kafka在内存中为每个文件维护了offset的范围。 下面是发送给 consumer 的结果的格式： 1234567891011121314MessageSetSend (fetch result)total length : 4 byteserror code : 2 bytesmessage 1 : x bytes...message n : x bytesMultiMessageSetSend (multiFetch result)total length : 4 byteserror code : 2 bytesmessageSetSend 1...messageSetSend n 4. 删除日志管理器允许定制删除策略。目前的策略是删除修改时间在N天之前的日志（按时间删除），也可以使用另外一个策略：保留最后的N GB数据的策略(按大小删除)。为了避免在删除时阻塞读操作，采用了copy-on-write形式的实现，删除操作进行时，读取操作的二分查找功能实际是在一个静态的快照副本上进行的，这类似于Java的CopyOnWriteArrayList。 5. 可靠性保证日志文件有一个可配置的参数M，缓存超过这个数量的消息将被强行刷新到硬盘。一个日志矫正线程将循环检查最新的日志文件中的消息确认每个消息都是合法的。合法的标准为：所有文件的大小的和最大的offset小于日志文件的大小，并且消息的CRC32校验码与存储在消息实体中的校验码一致。如果在某个offset发现不合法的消息，从这个offset到下一个合法的offset之间的内容将被移除。 有两种情况必须考虑： 当发生崩溃时有些数据块未能写入。 写入了一些空白数据块。第二种情况的原因是，对于每个文件，操作系统都有一个inode（inode是指在许多“类Unix文件系统”中的一种数据结构。每个inode保存了文件系统中的一个文件系统对象,包括文件、目录、大小、设备文件、socket、管道, 等等），但无法保证更新inode和写入数据的顺序，当inode保存的大小信息被更新了，但写入数据时发生了崩溃，就产生了空白数据块。CRC校验码可以检查这些块并移除，当然因为崩溃而未写入的数据块也就丢失了。 原文地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[闲言碎语，不知所云...]]></title>
      <url>http://ehlxr.me/2016/09/28/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD%EF%BC%8C%E4%B8%8D%E7%9F%A5%E6%89%80%E4%BA%91/</url>
      <content type="text"><![CDATA[闲言碎语，不知所云，乱七八糟，聊以自慰… 搭建博客有一段时间了，记录总结的基本都是技术相关的，对于一个有强迫症加语文学的不好的人来说，总结技术文章太痛苦了，总结一篇文章得纠结好久，总觉得组织的语言不够恰当准确，每次都是改了又改，反复琢磨，怎奈肚子里的墨水实在是少的可怜，真是羡慕那些可以把自己心里所想的东西用文字能够表达很清楚的人。 说到底还是看的东西少，缺少写东西的锻炼，青春迷茫的时候有大把机会可以利用，可惜都不知道把时间用在了哪儿，等慢慢想要沉淀的时候才发现工作和生活中琐碎已经占据了所有的时间。但不管怎样，从此刻启程，做一些自己想要做的事儿，我想应该不会太晚吧！ 搭建 Hexo 博客的初衷之一是觉得对于身为码农的我来说，Hexo 好玩，有新鲜感，对于非码农来说有一定的门槛（显的逼格高）。之二就是书写简单，不必局限于单一的编辑工具，少了刻意去追求排版样式烦恼。之三是觉得安全可靠，文章资源一切都可以掌控与自己，不必担心丢失，之前也买过 VPS 摆弄过 WordPress ，最后 VPS 租期到了，那段时间忙于找工作，博客的内容也没有及时保存下来，虽说博客没多少东西，但始终觉得有些遗憾… 夜深人不静，半夜公司楼下打车真是不好打。这几天每天到家都凌晨以后了，身体真是大不如前了…]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Oh My Zsh 替换你的 Bash Shell]]></title>
      <url>http://ehlxr.me/2016/09/24/Oh-My-Zsh-%E6%9B%BF%E6%8D%A2%E4%BD%A0%E7%9A%84-Bash-Shell/</url>
      <content type="text"><![CDATA[Oh-My-Zsh is an open source, community-driven framework for managing your ZSH configuration. It comes bundled with a ton of helpful functions, helpers, plugins, themes, and a few things that make you shout… Oh My ZSH! 1. Oh My Zsh 简介 无意中看见了 Linux 的一款 Shell，相比于 Bash 极其美艳，决定入坑试水一下，不试不知道，一试绝对有惊喜，不仅外观美艳而且功能强大，那还有不替换 Bash 的理由吗？搞起搞起…… Linux 提供了很多种 Shell ，想要查看系统有安装哪些 Shell 可以通过命令：chsh -l 或者 cat /etc/shells 进行查看。 1234567$ cat /etc/shells /bin/sh/bin/bash/sbin/nologin/usr/bin/sh/usr/bin/bash/usr/sbin/nologin 其中 Bash 是绝大多数 Linux 系统默认的 Shell，虽然 Zsh Shell 没有被所有 Linux 预安装，但几乎每一款 Linux 都包含 Zsh Shell， 根据不同版本的 Linux 可以用 apt-get、yum 等包管理器进行安装。 但是我们今天介绍的并非是 Zsh，而是 Oh My Zsh，这是个什么鬼了？虽说 Zsh Shell 很牛逼，但配置相当麻烦，所以阻挡了好多人尝试的勇气（我想这也是为啥 Zsh 不被 Linux 设为默认 Shell 的原因吧），但是永远不要低估一个爱折腾程序猿的创造力，国外一程序猿真就创造出了一款易于使用的 Zsh 版本：Oh My Zsh Oh My Zsh 几乎兼容日常使用的所有 Bash Shell 指令，让你可以无缝接入，不需要再去花额外的时间去适应。当然还扩展了大量炫酷的指令，要不然干嘛用它对吧，而且支持更换主题和插件机制。下面就开始搞起吧！ 2. 安装 安装 Oh My Zsh 首先需要安装 git 和 zsh，如果已经安装，请自行忽略。本文是基于 CentOS 介绍，其它 Linux 大致相同。 git 和 zsh 安装 12345# gitsodu yum install git# zshsodu yum install zsh Oh My Zsh 安装 Oh My Zsh 提供了 curl 和 wget 两种安装方式，选择任意一种自己方便的方式即可。 12345# via curlsudo sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;# via wgetsudo sh -c &quot;$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot; 3. 配置使用 切换 Shell 安装完成之后，使用以下命令即可切换当前 Shell： 1chsh -s /bin/zsh 退出当前终端连接，再次登入即可看到当前的 Shell 已经成功更改为 Oh My Zsh。 更改主题 Oh My Zsh 的配置文件路径为：~/.zshrc，配置文件中的 ZSH_THEME 就是主题配置字段，如下默认为 robbyrussell 主题配色。更多主题配色可参考 Oh My Zsh 主题，这里我推荐是用 ys 主题。 1ZSH_THEME=&quot;robbyrussell&quot; 其它 Linux 用户配置使用 Linux 其它用户想要使用 Oh My Zsh Shell，只需要拷贝当前用户家目录下的 ~/.zshrc 配置文件到当想要使用 Oh My Zsh Shell 用户的家目录下即可。需要注意的是配置文件中 Oh My Zsh 安装路径其它用户可以访问的到，所以最好更改为绝对路径，如下： 1export ZSH=/home/ehlxr/.oh-my-zsh 4. 插件配置 Oh My Zsh 支持插件机制，配置插件可以大大简化相关繁琐重复的命令。例如默认开启的 git 插件，就可以使用以下图表中的简写命令了： 那如何配置其它的插件了？只需要在 Oh My Zsh 的配置文件 ~/.zshrc 中找到 plugins=(git) 字段，配置插件的名称即可，多个插件使用空格隔开。 那支持哪些插件了？Oh My Zsh 安装目录下的 plugins 目录下就是支持的所有插件。例如：ls ~/.oh-my-zsh/plugins 就可以看到所有支持的插件名称了。 Oh My Zsh 支持插件的简写说明可以参看 oh-my-zsh Plugins wiki。 5. 常用命令简介 l 等价与 ls -la，查看当前目录下所有文件。 打开目录不需要再敲 cd，直接输入目录名即可。 TAB 提示更加聪明。 聪明的历史记录，例如：敲下 ls 命令，按下键盘 up 按键，就会带出以 ls 开头的历史记录命令。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[5 分钟搭建 Git 服务器-Gogs]]></title>
      <url>http://ehlxr.me/2016/09/06/5-%E5%88%86%E9%92%9F%E6%90%AD%E5%BB%BA-Git-%E6%9C%8D%E5%8A%A1%E5%99%A8-Gogs/</url>
      <content type="text"><![CDATA[Gogs 基于 Go 语言的自助 Git 服务。它具有易安装、跨平台、轻量级、开源化等特性… 最近新到一家公司，发现在使用 Gogs 搭建 Git 服务，遂研究了一下，和前段时间研究的 GitLab 做了一个简单的对比，虽然 Gogs 相对与 GitLab 还比较年轻，也许没有 GitLab 强大和稳健，但 Gogs 更加简单易用，而且能够满足正常的工作使用。 Gogs 是轻量级的 Git 服务，正如官方介绍的：一个廉价的树莓派的配置足以满足 Gogs 的最低系统硬件要求。最大程度上节省您的服务器资源！关键的一点是免费开源的，所有的代码都开源在 GitHub 上。下面结合官方的介绍，总结一下在 Linux 系统下的安装方法，真的是相当的简单，5 分钟足矣！ 安装 下载对应系统版本的二进制安装包，并上传至 Linux 系统，或通过以下命令下载： 1$ wget https://github.com/gogits/gogs/releases/download/v0.9.97/linux_amd64.tar.gz Gogs发布版本 解压安装包： 1$ tar -xzvf gogs_v0.9.97_linux_amd64.tar.gz 进入到刚刚解压后的目录执行命令 ./gogs web，出现以下信息： 打开浏览器输入：http://ip:3000，第一次会出现以下配置界面，根据实际情况选择即可 之后进入以下界面，安装完成。 后台运行可参考以下命令： 1$ nohup ./gogs web &gt; nohup.out 2&gt;&amp;1 &amp; 升级 引用自官方二级制升级文档 首先，确认当前安装的位置： 1234567# 默认位置在 git 用户下的家目录$ sudo su - git$ cd ~$ pwd/home/git$ lsgogs gogs-repositories 然后将当前目录移动到另一个临时的位置，但不是删除！ 1$ mv gogs gogs_old 下载并解压新的二进制： 12345# 请根据系统和类型获取相应的二进制版本$ wget https://dl.gogs.io/gogs_v$VERSION_$OS_$ARCH.tar.gz$ tar -zxvf gogs_v$VERSION_$OS_$ARCH.tar.gz$ lsgogs gogs_old gogs-repositories gogs_v$VERSION_$OS_$ARCH.tar.gz 复制 custom、data 和 log 目录到新解压的目录中： 123$ cp -R gogs_old/custom gogs$ cp -R gogs_old/data gogs$ cp -R gogs_old/log gogs 最后，运行并打开浏览器进行测试： 12$ cd gogs$ ./gogs web]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CentOS 中配置 Git 命令自动补全]]></title>
      <url>http://ehlxr.me/2016/09/04/CentOS-%E4%B8%AD%E9%85%8D%E7%BD%AE-Git-%E5%91%BD%E4%BB%A4%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8/</url>
      <content type="text"><![CDATA[1. 保存以下文件内容为：git-completion.bash https://github.com/git/git/blob/master/contrib/completion/git-completion.bash 2. 将上述文件git-completion.bash copy 至个人home目录 可设为隐藏文件以免后续被误删 1$ cp git-completion.bash ~/.git-completion.bash 3. 编辑环境变量文件1$ vi ~/.bashrc 在最后加入下面内容 1source ~/.git-completion.bash 完成以上步骤后，重启shell，就可以通过tab键自动补全Git命令.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Naruto-Pictures]]></title>
      <url>http://ehlxr.me/2016/09/02/Naruto-Pictures/</url>
      <content type="text"><![CDATA[]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用Hexo基于GitHub Pages搭建个人博客（三）]]></title>
      <url>http://ehlxr.me/2016/08/30/%E4%BD%BF%E7%94%A8Hexo%E5%9F%BA%E4%BA%8EGitHub-Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      <content type="text"><![CDATA[生命不息，折腾不休。从搭建 blog 以来，博文虽没有写几篇，但折腾的时间花了不少，走过了不少弯路，也踩过了不少的坑，虽然很懒，但本着好记性不如烂笔头的宗旨，打算在折腾记忆尚未磨灭之际记录一下走过的路和踩过的坑… 接着前两篇使用 Hexo 基于 GitHub Pages 搭建个人博客之上，本文记录了在使用非常漂亮简洁的 Next 主题过程中的各种折腾，其它主题的相关设置大同小异。再次衷心的感谢 Hexo 的作者和 Next 主题作者的无私奉献。 一、主题基本配置 记录一下 Next 主题的基本配置、设置「阅读全文」、关闭新建页面的评论功能、页面文章的篇数、宽度调节、设置「JavaScript 第三方库」等内容、在线字体替换（选择关闭，加快访问速度） 主题安装 Next 主题安装与所有 Hexo 主题安装一样。当克隆或者下载（Next主题GitHub地址）完成主题文件后，拷贝至站点目录的 themes 目录下，一般命名为 next，打开站点配置文件， 找到 theme 字段，并将其值更改为 next 即可。 1theme: next Next 主题宽度调节 编辑 themes/next/source/css/_variables/custom.styl 文件，新增变量： 12345// 修改成你期望的宽度$content-desktop = 700px// 当视窗超过 1600px 后的宽度$content-desktop-large = 900px 以上方法不适用 Pisces Scheme Pisces Scheme 编辑 themes/next/source/css/_schemes/Picses/_layout.styl 文件，更改以下 css 选项定义值： 123.header&#123; width: 1150px; &#125;.container .main-inner &#123; width: 1150px; &#125;.content-wrap &#123; width: calc(100% - 260px); &#125; 二、多说评论 登录多说后在首页选择 “我要安装”。 创建站点，填写表单。多说域名 这一栏填写的即是你的 duoshuo_shortname，如图： 创建站点完成后在 主题配置文件 中新增 duoshuo_shortname 字段，值设置成上一步中的值。 开启多说热评文章，在 主题配置文件 中设置 duoshuo_hotartical 的值为 true 即可 多说评论样式调整，登录多说后在首页右上角点击“后台管理”，选择站点名称打开多说后台管理页面，选择“设置”下拉找到“自定义CSS”输入框，填写以下CSS样式，效果参考本站文章结尾评论样式。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/*-------------访客底部----------------*/.ds-recent-visitors &#123; margin-bottom: 200px;&#125;@media (max-width: 768px) &#123; .ds-recent-visitors &#123; margin-bottom: 440px; &#125;&#125;/*-------------非圆角----------------*/#ds-reset .ds-rounded &#123; border-radius: 0px;&#125;.theme-next #ds-thread #ds-reset .ds-textarea-wrapper &#123; border-top-right-radius: 0px; border-top-left-radius: 0px;&#125;.theme-next #ds-thread #ds-reset .ds-post-button &#123; border-radius: 0px;&#125;.ds-post-self xmp &#123; word-wrap: break-word;&#125;/*-------------访客----------------*/#ds-reset .ds-avatar img,#ds-recent-visitors .ds-avatar img &#123; width: 54px; height: 54px; /*设置图像的长和宽，这里要根据自己的评论框情况更改*/ border-radius: 27px; /*设置图像圆角效果,在这里我直接设置了超过width/2的像素，即为圆形了*/ -webkit-border-radius: 27px; /*圆角效果：兼容webkit浏览器*/ -moz-border-radius: 27px; box-shadow: inset 0 -1px 0 #3333sf; /*设置图像阴影效果*/ -webkit-box-shadow: inset 0 -1px 0 #3333sf; -webkit-transition: 0.4s; -webkit-transition: -webkit-transform 0.4s ease-out; transition: transform 0.4s ease-out; /*变化时间设置为0.4秒(变化动作即为下面的图像旋转360读）*/ -moz-transition: -moz-transform 0.4s ease-out;&#125;/*-------------访客悬浮在头像----------------*/#ds-reset .ds-avatar img:hover,#ds-recent-visitors .ds-avatar img:hover &#123; box-shadow: 0 0 10px #fff;rgba(255, 255, 255, .6), inset 0 0 20 px rgba(255, 255, 255, 1); -webkit-box-shadow: 0 0 10px #fff;rgba(255, 255, 255, .6), inset 0 0 20 px rgba(255, 255, 255, 1); transform: rotateZ(360deg); /*图像旋转360度*/ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg);&#125;#ds-thread #ds-reset .ds-textarea-wrapper textarea &#123; background: url(http://ww4.sinaimg.cn/small/649a4735gw1et7gnhy5fej20zk0m8q3q.jpg) right no-repeat;&#125;#ds-recent-visitors .ds-avatar &#123; float: left&#125;/*-------------隐藏版权----------------*/#ds-thread #ds-reset .ds-powered-by &#123; display: none;&#125; 三、统计 我使用 LeanCloud 统计文章阅读数，使用不蒜子统计站点的 PV 和 UV 数。 文章阅读次数统计（LeanCloud) 参考为NexT主题添加文章阅读量统计功能 不蒜子统计站点访问统计 编辑 主题配置文件 中的 busuanzi_count 的配置项，配置以下内容： 1234567891011121314151617# count values only if the other configs are falseenable: true# custom uv span for the whole sitesite_uv: truesite_uv_header: &lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt;site_uv_footer:# custom pv span for the whole sitesite_pv: truesite_pv_header: &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt;site_pv_footer:# custom pv span for one page onlypage_pv: falsepage_pv_header: &lt;i class=&quot;fa fa-file-o&quot;&gt;&lt;/i&gt;page_pv_footer: site/page_pv/uv_header 和 site/page_pv/uv_footer 为自定义样式配置，相关的值留空时将不显示，可以使用（带特效的）font-awesome。 四、设置 RSS 安装 hexo-generator-feed，在站点的根目录下执行以下命令： 1$ npm install hexo-generator-feed --save 编辑 站点配置文件，新增以下内容到任意位置： 123456789# RSS订阅支持plugin:- hexo-generator-feed# Feed Atomfeed:type: atompath: atom.xmllimit: 20 五、内容分享 使用 JiaThis 作为内容分享服务，具体步骤如下： 编辑 站点配置文件， 添加字段 jiathis，值为 true 即可。 六、搜索服务 1. 安装 hexo-generator-search，在站点的根目录下执行以下命令： 1$ npm install hexo-generator-search --save 2. 编辑 站点配置文件，新增以下内容到任意位置： 123search: path: search.xml field: post 安装 hexo-generator-searchdb，在站点的根目录下执行以下命令： 1$ npm install hexo-generator-searchdb --save 编辑 站点配置文件，新增以下内容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 七、背景效果 介绍博客背景动态效果图和点击小红心效果的相关设置。 把 js 文件 love.js 和 particle.js 放在\themes\next\source\js\src文件目录下 更新\themes\next\layout\_layout.swig文件，在末尾（在前面引用会出现找不到的bug）添加以下 js 引入代码： 1234&lt;!-- 背景动画 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/particle.js&quot;&gt;&lt;/script&gt;&lt;!-- 页面点击小红心 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/love.js&quot;&gt;&lt;/script&gt; 八、图片模式 新建博文，设置type: &quot;picture&quot;，使用{\% gp x-x \%} ... {\% endgp \%}标签引用要展示的图片地址，如下所示： 12345678910111213141516---title: Naruto-Picturescategories: [图片]tags: [picture,naruto]date: 2016-09-02 14:36:04keywords: picture,narutotype: &quot;picture&quot;top: 999---&#123;% gp 5-3 %&#125;![](http://oapjp6spr.bkt.clouddn.com/18210.jpg)![](http://oapjp6spr.bkt.clouddn.com/196232.jpg)![](http://oapjp6spr.bkt.clouddn.com/224147.jpg)![](http://oapjp6spr.bkt.clouddn.com/199301.jpg)![](http://oapjp6spr.bkt.clouddn.com/213318.jpg)&#123;% endgp %&#125; {\% gp 5-3 \%}：设置图片展示效果，参考theme/next/scripts/tags/group-pictures.js注释效果 九、博文压缩 目前知道的有两个插件可以压缩博文，hexo-all-minifier插件和gulp插件。hexo-all-minifier插件虽然使用比较简单，而且可以压缩图片，但是发现对文章缩进（输入法全拼模式下按Tab）不支持，所以暂时使用第二种压缩手段。 hexo-all-minifier配置使用 安装 hexo-all-minifier，在站点的根目录下执行以下命令： 1$ npm install hexo-all-minifier --save hexo g生产博文的时候就会自动压缩 HTML、JS、图片，详情参考插件介绍 gulp插件配置使用 hexo依赖gulp插件安装，在站点的根目录下执行以下命令： 12$ npm install gulp -g$ npm install gulp-minify-css gulp-uglify gulp-htmlmin gulp-htmlclean gulp --save 在package.json同级目录下，新建gulpfile.js并填入以下内容： 12345678910111213141516171819202122232425262728293031323334var gulp = require(&apos;gulp&apos;);var minifycss = require(&apos;gulp-minify-css&apos;);var uglify = require(&apos;gulp-uglify&apos;);var htmlmin = require(&apos;gulp-htmlmin&apos;);var htmlclean = require(&apos;gulp-htmlclean&apos;);// 压缩 public 目录 cssgulp.task(&apos;minify-css&apos;, function() &#123; return gulp.src(&apos;./public/**/*.css&apos;) .pipe(minifycss()) .pipe(gulp.dest(&apos;./public&apos;));&#125;);// 压缩 public 目录 htmlgulp.task(&apos;minify-html&apos;, function() &#123; return gulp.src(&apos;./public/**/*.html&apos;) .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest(&apos;./public&apos;))&#125;);// 压缩 public/js 目录 jsgulp.task(&apos;minify-js&apos;, function() &#123; return gulp.src(&apos;./public/**/*.js&apos;) .pipe(uglify()) .pipe(gulp.dest(&apos;./public&apos;));&#125;);// 执行 gulp 命令时执行的任务gulp.task(&apos;default&apos;, [ &apos;minify-html&apos;,&apos;minify-css&apos;,&apos;minify-js&apos;]); 生成博文是执行hexo g &amp;&amp; gulp就会根据gulpfile.js中的配置，对public目录中的静态资源文件进行压缩。 十、博文置顶 修改hexo-generator-index插件 替换文件：node_modules/hexo-generator-index/lib/generator.js 为：generator.js 在文章中添加top值，数值越大文章越靠前，如： 123456789---title: Naruto 图集categories: [图片]tags: [picture,naruto]date: 2016-09-02 14:36:04keywords: picture,narutotype: &quot;picture&quot;top: 10--- 十一、头像圆形旋转 介绍一下实现头像圆形，鼠标经过旋转或者一直让旋转效果，主要是修改 Hexo 目录下 \themes\next\source\css\_common\components\sidebar\sidebar-author.styl 文件。 头像圆形：修改 sidebar-author.styl 文件中 .site-author-image CSS 样式如下： 12345678910111213.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /*头像圆形*/ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px;&#125; 鼠标经过旋转：修改 sidebar-author.styl 文件，添加 CSS 样式 img:hover 如下代码： 123456img:hover &#123; /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125; 修改 sidebar-author.styl 文件中 .site-author-image CSS 样式如下： 12345678910111213141516171819.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.5s ease-out; -moz-transition: -moz-transform 1.5s ease-out; transition: transform 1.5s ease-out;&#125; 一直旋转效果：修改 sidebar-author.styl 文件，添加如下代码： 12345678910111213141516171819202122232425/* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(360deg); &#125;&#125; 修改 sidebar-author.styl 文件中 .site-author-image CSS 样式如下： 12345678910111213141516171819202122232425.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画：animation:动画名称 动画播放时长单位秒或微秒 动画播放的速度曲线linear为匀速 动画播放次数infinite为循环播放; */ -webkit-animation: play 3s linear infinite; -moz-animation: play 3s linear infinite; animation: play 3s linear infinite; /* 鼠标经过头像旋转360度 -webkit-transition: -webkit-transform 1.5s ease-out; -moz-transition: -moz-transform 1.5s ease-out; transition: transform 1.5s ease-out;*/&#125; 鼠标经过停止头像旋转：修改 sidebar-author.styl 文件，添加 CSS 样式 img:hover 如下代码： 12345678910img:hover &#123; /* 鼠标经过停止头像旋转 */ -webkit-animation-play-state:paused; animation-play-state:paused; /* 鼠标经过头像旋转360度 -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);*/&#125; 完整 sidebar-author.styl 文件参考地址。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[转]Java程序员情书]]></title>
      <url>http://ehlxr.me/2016/08/22/%E8%BD%AC-Java%E7%A8%8B%E5%BA%8F%E5%91%98%E6%83%85%E4%B9%A6/</url>
      <content type="text"><![CDATA[我能抽象出整个世界．．． 但是我却不能抽象出你．．． 你肯定是一个单例，因为你是那样的独一无二… 所以我的世界并不完整．．． 我可以重载甚至覆盖这个世界里的任何一种方法．．． 但是却不能覆盖对你的思念．．． 也许命中注定了 你与我存在于不同的包里… 在你的世界里，你被烙上了私有的属性… 我用尽全身力气，也找不到访问你的接口… 我不愿就此甘心，找到了藏身在神殿的巫师，教会了我穿越时空的方法… 终于，我用反射这把利剑，打开了你空间的缺口… 并发现了接近你的秘密… 当我迫不及待地调用了爱你这个方法．．． 并义无返顾的把自己作为参数传进这个方法时．．． 我才发现爱上你是一个没有终止条件的递归．．． 它不停的返回我对你的思念并压入我心里的堆栈．．． 在这无尽的黑夜中 ，终于体验到你对我爱的回调… 我的内存里已经再也装不下别人… 当我以为将与你在这个死循环中天荒地老时… 万恶的系统抛出了爱的异常… 此刻我才发现，我不过是操纵于虚拟机下的一个线程，你也是… 但我毫不后悔，因为在爱的洗礼之后… 我看见了一个新的生命，那是我们的, 继承]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CentOS 系统下 GitLab 搭建与基本配置]]></title>
      <url>http://ehlxr.me/2016/07/31/CentOS-%E7%B3%BB%E7%BB%9F%E4%B8%8B-GitLab-%E6%90%AD%E5%BB%BA%E4%B8%8E%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/</url>
      <content type="text"><![CDATA[GitLab 是一个开源的版本管理系统，提供了类似于 GitHub 的源代码浏览，管理缺陷和注释等功能，你可以将代码免费托管到 GitLab.com，而且不限项目数量和成员数。最吸引人的一点是，可以在自己的服务器上搭建 GitLab CE （社区免费版）版本，方便内部团队协作开发和代码管理。 下面介绍如何在 CentOS 服务器上搭建 GitLab CE 版本，以及一些基本的配置。 1. 安装 GitLab 提供了两种安装方式：源码手动编译安装和软件包管理安装。 源码手动编译安装虽然配置灵活，但过程比较麻烦，不容易安装成功，所以我这里选择软件包管理安装的形式。 使用 GitLab 提供仓库在线安装 12curl -sS https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh | sudo bashyum install gitlab-ce 国外的 GitLab 仓库访问速度较慢，可以使用国内的站点： 12curl -sS http://packages.gitlab.cc/install/gitlab-ce/script.rpm.sh | sudo bashyum install gitlab-ce 下载离线软件包安装 如果网络速度不理想，可以使用离线软件包 rpm 的方式进行安装，下面提供了几个站点的下载地址。 GitLab 官方：https://packages.gitlab.com/gitlab/gitlab-ce?filter=rpms 清华大学TUNA开源镜像站：https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el7/ 浙大开源镜像站：http://mirrors.lifetoy.org/gitlab-ce/yum/el7/ 下载好 rpm 软件安装包后上传到服务器指定的目录下，通过以下命令进行安装： 1rpm -ivh gitlab-ce-8.9.6-ce.0.el7.x86_64.rpm 记录一下 rpm 卸载软件安装包命令： 1rpm -e --nodeps gitlab-ce-8.9.6-ce.0.el7.x86_64 2. 启动 GitLab 安装完成之后，打开配置文件 /etc/gitlab/gitlab.rb 将 external_url = &#39;http://git.example.com&#39; 修改为自己的 IP 地址：external_url &#39;http://ip_address&#39; ，然后执行下面的命令，对 GitLab 进行编译： 1gitlab-ctl reconfigure 完成后，使用浏览器访问：http://ip_address 可进入 GitLab 登录页面，首次访问系统会让你重新设置管理员的密码，默认的管理员账号是 root，如果你想更改默认管理员账号，登录系统后可以修改帐号名。 3. GitLab 基本配置 GitLab 的相关参数配置都存在 /etc/gitlab/gitlab.rb 文件里。自 GitLab 7.6 开始的新安装包, 已经默认将所有的参数写入到 /etc/gitlab/gitlab.rb 配置文件中。 配置端口 GitLab 默认使用 80 端口对外提供服务，因为 80 端口被其他服务占用，所以需要更改。打开 /etc/gitlab/gitlab.rb 配置文件，修改 external_url &#39;http://ip_address&#39; 为 external_url &#39;http://ip_address:new-port&#39;， 重新编译配置： 1gitlab-ctl reconfigure 这时候就可以通更改后的 IP + 端口号码进行访问了。 邮箱配置 以下是 163 邮箱的配置参考，打开 /etc/gitlab/gitlab.rb 配置文件，添加以下内容： 12345678gitlab_rails[&apos;smtp_enable&apos;] = truegitlab_rails[&apos;smtp_address&apos;] = &quot;smtp.163.com&quot;gitlab_rails[&apos;smtp_port&apos;] = 25gitlab_rails[&apos;smtp_user_name&apos;] = &quot;test@163.com&quot;gitlab_rails[&apos;smtp_password&apos;] = &quot;password&quot;gitlab_rails[&apos;smtp_authentication&apos;] = &quot;login&quot;gitlab_rails[&apos;smtp_enable_starttls_auto&apos;] = truegitlab_rails[&apos;gitlab_email_from&apos;] = &quot;test@163.com&quot; 注意： test@163.com 和 password 更新为自己邮箱地址和密码；邮箱需要开启 SMTP 协议。 重新编译配置即可生效： 1gitlab-ctl reconfigure 其它邮箱的配置可参考：https://doc.gitlab.cc/omnibus/settings/smtp.html 头像配置 GitLab 默认使用的是 Gravatar 头像服务，不过现在貌似 Gravatar 国内好像访问不了，导致 GitLab 默认头像破裂，无法显示，可以替换为多说 Gravatar 服务器。打开 /etc/gitlab/gitlab.rb 配置文件，增加下面这一行： 1gitlab_rails[&apos;gravatar_plain_url&apos;] = &apos;http://gravatar.duoshuo.com/avatar/%&#123;hash&#125;?s=%&#123;size&#125;&amp;d=identicon&apos; 再分别执行以下命令即可 12gitlab-ctl reconfigure gitlab-rake cache:clear RAILS_ENV=production 也可以关闭 Gravatar 头像显示配置，登录 GitLab 管理员账户，进入设置界面（路径地址：http://ip:port/admin/application_settings ），取消以下选项即可。 用户注册配置 管理员设置界面（路径地址：http://ip:port/admin/application_settings ）以下选项可以控制用户注册配置，包括是否允许登录、注册和注册邮箱验证等选项。 常用命令 GitLab 服务启动、停止、状态查询、修改配置生效等命令： 1gitlab-ctl start/stop/status/reconfigure # 服务启动、停止、状态查询、修改配置生效 也可以查看帮助文档获取更多命令信息： 1gitlab-ctl --help]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CentOS 7 安装最新的 Git]]></title>
      <url>http://ehlxr.me/2016/07/30/CentOS-7-%E5%AE%89%E8%A3%85%E6%9C%80%E6%96%B0%E7%9A%84-Git/</url>
      <content type="text"><![CDATA[yum 源仓库里的 Git 版本更新不及时，最新版本的 Git 是 1.8.3.1，但是官方最新版本已经到了 2.9.2。想要安装最新版本的的 Git，只能下载源码进行安装。 1. 查看 yum 源仓库的 Git 信息：1# yum info git 可以看出，截至目前，yum 源仓库中最新的 Git 版本才 1.8.3.1，而查看最新的 Git 发布版本，已经 2.9.2 了。 2. 依赖库安装12# yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel# yum install gcc perl-ExtUtils-MakeMaker 3. 卸载低版本的 Git 通过命令：git –-version 查看系统带的版本，Git 版本是： 1.8.3.1，所以先要卸载低版本的 Git，命令： 1# yum remove git 4. 下载新版的 Git 源码包1# wget https://github.com/git/git/archive/v2.9.2.tar.gz 也可以离线下载，然后传到 CentOS 系统中指定的目录下。 5. 解压到指定目录1# tar -xzvf v2.9.2.tar.gz -C ~/app/ 6. 安装 Git 分别执行以下命令进行编译安装，编译过程可能比较漫长，请耐心等待完成。 123# cd git-2.9.2# make prefix=/usr/local/git all# make prefix=/usr/local/git install 7. 添加到环境变量12# echo &quot;export PATH=$PATH:/usr/local/git/bin&quot; &gt;&gt; /etc/bashrc# source /etc/bashrc # 实时生效 8. 查看版本号12# git --versiongit version 2.9.2 至此，CentOS 就安装上了最新版本的 Git。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CentOS 7 安装 Node.js]]></title>
      <url>http://ehlxr.me/2016/07/30/CentOS-7-%E5%AE%89%E8%A3%85-Node-js/</url>
      <content type="text"><![CDATA[Node.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine. Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient. Node.js’ package ecosystem, npm, is the largest ecosystem of open source libraries in the world. 1. 下载源码安装文件 方式一：在线安装 通过以下命令下载源文件： 1wget https://nodejs.org/dist/v4.4.7/node-v4.4.7.tar.gz 方法二：离线安装 如果网络不好，可以通过官方网站下载，然后上传到 CentOS 系统中，下载如图所示： 我这儿官方网站是无法正常访问的，需要一些手段（大家懂得），所以在网盘备份一份，地址：http://pan.baidu.com/s/1bpIAUAz 2. 编译安装 解压文件到指定的目录 1tar -xzvf node-v4.4.7.tar.gz -C app/ 安装依赖包 1yum install gcc gcc-c++ 配置安装 1./configure ./configure 是源代码安装的第一步，主要的作用是对即将安装的软件进行配置，检查当前的环境是否满足要安装软件的依赖关系，生成 makefile文件，以便你可以用 make 和 make install 来编译和安装程序。 编译安装编译命令： 1make 编译的过程会花很长一段时间，等编译完成再执行安装命令： 1make install 3. 检查安装 运行以下命令： 1node --version 若输出对应的版本号，则安装成功。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[转]将 Centos 的 yum 源更改为国内的阿里云源]]></title>
      <url>http://ehlxr.me/2016/07/30/%E8%BD%AC-%E5%B0%86-Centos-%E7%9A%84-yum-%E6%BA%90%E6%9B%B4%E6%94%B9%E4%B8%BA%E5%9B%BD%E5%86%85%E7%9A%84%E9%98%BF%E9%87%8C%E4%BA%91%E6%BA%90/</url>
      <content type="text"><![CDATA[阿里云Linux安装镜像源地址：http://mirrors.aliyun.com/ CentOS系统更换软件安装源 一. 备份你的原镜像文件，以免出错后可以恢复。 1mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup 二. 下载新的 CentOS-Base.repo 到 /etc/yum.repos.d/ CentOS 5 1wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-5.repo CentOS 6 1wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-6.repo CentOS 7 1wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo 三. 运行 yum makecache 生成缓存 12yum clean allyum makecache]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Oracle 与 MySQL 知识总结]]></title>
      <url>http://ehlxr.me/2016/07/28/Oracle-%E4%B8%8E-MySQL-%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
      <content type="text"><![CDATA[对日常工作中使用 Oracle 和 MySQL 数据库知识对比总结。 1. SQLPlus 连接数据库的方式 cmd 中输入：sqlplus 用户名/密码@数据库实例 12sqlplus system/lxr316@oraclesqlplus sys/admin as sysdba 打开 SQLPlus 直接输入用户名和密码 使用命令： 12connect sys/admin as sysdbaconnect system/lxr316 超级管理员登录： 1sys as sysdba 断开数据库： 1disconnect; # 可简写 disconn 2. MySQL 连接 命令： mysql [–h 服务器地址] –u 用户名 –p [密码]（需要配置 mysql 数据库的 bin 到环境变量中） 12mysql -h localhost –u root –p rootmysql –u root -p 3. 用户操作 Oracle 创建用户 1create user [username] identified by [password]; 修改用户密码 1alter user [username] identified by [password]; 账户上锁、解锁 1alter user [username] account lock|unlock; 用户首次登录时直接修改密码–密码失效 1alter user [username] password expire; MySQL 创建用户: 1CREATE USER &apos;username&apos;@&apos;host&apos; IDENTIFIED BY &apos;password&apos;; 备注： username：你将创建的用户名。 host：指定该用户在哪个主机上可以登陆,如果是本地用户可用localhost, 如果想让该用户可以从任意远程主机登陆,可以使用通配符%。 password：该用户的登陆密码,密码可以为空,如果为空则该用户可以不需要密码登陆服务器。 例如： 12345CREATE USER &apos;dog&apos;@&apos;localhost&apos;IDENTIFIED BY &apos;123456&apos;;CREATE USER &apos;pig&apos;@&apos;192.168.1.101_&apos;IDENDIFIED BY &apos;123456&apos;;CREATE USER &apos;pig&apos;@&apos;%&apos; IDENTIFIED BY &apos;123456&apos;;CREATE USER &apos;pig&apos;@&apos;%&apos; IDENTIFIED BY &apos;&apos;;CREATE USER &apos;pig&apos;@&apos;%&apos;; 设置与更改用户密码 1SET PASSWORD FOR &apos;username&apos;@&apos;host&apos; = PASSWORD(&apos;newpassword&apos;); 如果是当前登陆用户 1SET PASSWORD = PASSWORD(&quot;newpassword&quot;); 删除用户 1DROP USER &apos;username&apos;@&apos;host&apos;; 4. 权限管理 Oracle 授权 12grant 权限 to 用户名;grant all on 表名 to用户/角色 收回权限 1revoke 权限from 用户名; 对象权限可以级联收回，但是系统权限不可以级联收回。 (1) 系统权限： A 赋予一个系统权限给 B，B 再授予 C。然后A将该权限从 B 回收，此后 C 仍然有该权限。 (2) 对象权限： A 赋予一个对象权限给 B，B 再授予 C。然后A将该权限从 B 回收，此后 C 也失去了该权限。 常用系统权限 123create session --用户登录create table --创建表unlimited tablespace --无限表空间 常用对象权限 1234select on 表名; -- 查询权限update on 表名; -- 更新权限delete on 表名; -- 删除权限insert on 表名; -- 插入权限 权限的级联授予 1grant 权限 to 用户名 with admin option|with grant option; with admin option：系统权限 with grant option：对象权限 MySQL 授权: 1GRANT privileges ON databasename.tablename TO &apos;username&apos;@&apos;host&apos; 备注： privileges：用户的操作权限,如 SELECT , INSERT , UPDATE 等；如果要授予所的权限则使用 ALL。 databasename：数据库名。 tablename：表名 如果要授予该用户对所有数据库和表的相应操作权限则可用 * 表示, 如 *.* 。 例如: 123GRANT SELECT, INSERT ON test.user TO &apos;pig&apos;@&apos;%&apos;; GRANT ALL ON *.* TO &apos;pig&apos;@&apos;%&apos;; 注意： 用以上命令授权的用户不能给其它用户授权，如果想让该用户可以授权，用以下命令: 1GRANT privileges ON databasename.tablename TO &apos;username&apos;@&apos;host&apos; WITH GRANT OPTION; 撤销用户权限 1REVOKE privilege ON databasename.tablename FROM &apos;username&apos;@&apos;host&apos;; 说明： privilege, databasename, tablename - 同授权部分。 例如： 1REVOKE SELECT ON *.* FROM &apos;pig&apos;@&apos;%&apos;; 注意： 假如你在给用户 &#39;pig&#39;@&#39;%&#39; 授权的时候是这样的（或类似的）：GRANT SELECT ON test.user TO &#39;pig&#39;@&#39;%&#39;; 则在使用：REVOKE SELECT ON *.* FROM&#39;pig&#39;@&#39;%&#39;; 命令并不能撤销该用户对 test 数据库中 user 表的 SELECT 操作；相反，如果授权使用的是：GRANT SELECT ON *.* TO&#39;pig&#39;@&#39;%&#39;; 则：REVOKE SELECT ONtest.user FROM &#39;pig&#39;@&#39;%&#39;; 命令也不能撤销该用户对 test 数据库中 user 表的 SELECT 权限。 具体信息可以用命令：SHOW GRANTS FOR &#39;pig&#39;@&#39;%&#39;; 查看。 5. Oracle角色 role 角色：权限的集合 角色数据字典表 查看当前用户中的角色：user_role_privs 查看角色中的系统权限：role_sys_privs 查看角色中的对象权限：role_tab_privs 建一个角色 1create role role1; 授权给角色 1grant create any table, create procedure to role1; 授予/回收用户角色 123grant role1 to user1;revoke role1 from user1; 创建带有口令以角色 在生效带有口令的角色时必须提供口令 1create role role1 identified by password1; 修改角色：是否需要口令 123alter role role1 not identified;alter role role1 identified by password1; 设置当前用户要生效的角色 12345678910111213set role role1; -- 使 role1 生效set role role1, role2; -- 使 role1, role2 生效set role role1 identified by password1; -- 使用带有口令的 role1 生效set role all; -- 使用该用户的所有角色生效set role none; -- 设置所有角色失效set role all except role1; -- 除 role1 外的该用户的所有其它角色生效select * from SESSION_ROLES; -- 查看当前用户的生效的角色。 修改指定用户，设置其默认角色 123alter user user1 default role role1;alter user user1 default role all except role1; 删除角色 1drop role role1; 注意： 角色删除后，原来拥用该角色的用户就不再拥有该角色了，相应的权限也就没有了。 系统角色 DBA: 拥有全部特权，是系统最高权限角色 RESOURCE：拥有 RESOURCE 角色权限的用户只可以创建实体 CONNECT：拥有 CONNECT 角色权限的用户只可以登录 Oracle 对于普通用户：授予 CONNECT，RESOURCE 角色权限；对于DBA管理用户：授予 CONNECT，RESOURCE， DBA 角色权限。 6. 查看表结构信息命令 Oracle 1desc(ribe) 表名; -- 如：desc lxr MySQL 1desc(ribe) 表名; 7. 显示当前登录用户： Oracle 1show user; MySQL 1select user(); 8. MySQL 查看用户下的数据库1show databases; 查看表 1show tables; 9. Oracle 用户锁定与解锁123ALTER USER username ACCOUNT LOCK; -- 锁定用户ALTER USER username ACCOUNT UNLOCK; -- 解锁用户 10. 清屏命令 SQLPlus 123clear screen -- 简写：cl scrcls -- dos 清屏命令 MySQL 123system clear; -- Linux 环境下system cls; -- dos 环境下 11. Oracle 更改当前用户日期格式命令1alter session set nls_date_format = &apos;yyyy-mm-dd&apos;; 12. Oracle 中的基本数据类型 数值：number(5,2)，int 字符：char，varchar2(4000) 日期：date 图片：BLOB (binaryLargeObject) 4G 文本：CLOB (Character LargeObject) 4G 13. Oracle 表结构操作 表重命名 1alter table 表名 rename to 新表名; 给表增加注释 1comment on table 表名 is &apos;注释内容&apos;; 添加约束方式 方式一 1alter table 表名 add constraint 约束名 约束类型(约束的字段名); constraint 约束类型： 值 名称 primary key 主键 unique 唯一 check 限制 not null 不能为null 方式二 1alter table 表名 add constraint 约束名 foreign key(字段名) references 表名(字段名); foreign key 外键： 参照主键中存在的值，可以插入重复的记录、可以插入重复的空值 删除约束方式 1alter table 表名 drop constraint 约束名; 删除表结构 1drop table 表名; -- 此操作属DDL，会自动提交且不可回滚 表中增加字段 1alter table 表名 add 字段名 类型; 删除字段 1alter table 表名 drop 字段名; 通常在系统不忙的时候删除不使用的字段，可以先设置字段为 unused 1alter table test3 set unused column address; 再执行删除 1alter table test3 unused column; 字段重命名 1alter table 表名 rename column 字段名 to 新字段名; 修改字段 1alter table 表名 modify 字段名 新类型; 添加 not null 1alter table 表名 modify 字段名 not null 删除 not null 1alter table 表名 modify 字段名 null; 14. Oracle 备份表 在当前的数据库之内进行备份 1create table 表名(字段) as select 查询语句; 数据的移动 1insert into 表名（字段列表）select 字段列表 from 表名; 数据库服务器之间拷贝表 知识点： 客户端连接服务器 1copy from system/hhl@hhl create hhl_table using select * from scott.emp; 从A服务器拷贝到自己的数据库中 1copy from 用户名/密码@主机字符串 create 表名 using 查询语句; 从自己的数据库中拷贝到A服务器 1copy to 用户用/密码@主机字符串 create 表名 using 查询语句; 从A服务器拷贝表到B服务器 1copy from 用户用/密码@主机字符串 to 用户用/密码@主机字符串 create 表名 using 查询语句; 15. OracleDBLINK 数据库连接 在当前的数据库内直接操作其他服务器中的表做增删改查，格式如下： 1create database link 名 connect to 用户名 identified by 密码 using &apos;主机字符串&apos;; 16. MySQL 查看数据库字符集123show variables like &apos;character%&apos;;show variables like &apos;%collation%&apos;; 17. truncate 与 delete 使用格式 123truncate table 表名; -- 删除表中全部记录delete from 表名; truncate 与 delete 的区别 truncate 删除速度比 delete 删除速度快； truncate 不可以回滚，delete 可以回滚。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[GitHub 更新已经 fork 的项目]]></title>
      <url>http://ehlxr.me/2016/07/28/GitHub-%E6%9B%B4%E6%96%B0%E5%B7%B2%E7%BB%8F-fork-%E7%9A%84%E9%A1%B9%E7%9B%AE/</url>
      <content type="text"><![CDATA[GitHub 上有个很方便的功能叫 fork，将别人的工程一键复制到自己账号下。这个功能很方便，但有点不足的是，当源项目更新后，你 fork 的分支并不会一起更新，需要自己手动去更新，下面记录下网上找到的更新的开发方法。 1. 在本地装好 GitHub 客户端，或者 Git 客户端2. clone 自己的 fork 分支到本地 可以直接使用 GitHub 客户端，clone 到本地，如果使用命令行，命令为： 1$ git clone git@github.com:ehlxr/strman-java.git 3. 增加源分支地址到你项目远程分支列表中 此处是关键，先得将原来的仓库指定为 upstream，命令为： 1$ git remote add upstream git@github.com:shekhargulati/strman-java.git 此处可使用 git remote -v 查看远程分支列表 12345$ git remote -vorigin git@github.com:ehlxr/strman-java.git (fetch)origin git@github.com:ehlxr/strman-java.git (push)upstream git@github.com:shekhargulati/strman-java.git (fetch)upstream git@github.com:shekhargulati/strman-java.git (push) 4. fetch 源分支的新版本到本地1$ git fetch upstream 5. 合并两个版本的代码1$ git merge upstream/master 6. 将合并后的代码 push 到 GitHub 上去1$ git push origin master 参考网址： https://help.github.com/articles/fork-a-repo 原文出处]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Sublime Text 插件安装]]></title>
      <url>http://ehlxr.me/2016/07/25/Sublime-Text-%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85/</url>
      <content type="text"><![CDATA[Sublime Text 官方介绍： “Sublime Text is a sophisticated text editor for code, markup and prose.You’ll love the slick user interface, extraordinary features and amazing performance.” Sublime Text 是一款优秀的轻量级编辑器，而且支持跨平台，支持Windows、Linux、Mac OS X 等主流操作系统。虽然是一款收费软件，但也允许人们无限期免费使用。（官方下载地址） Sublime Text 具有漂亮的用户界面和强大可扩展插件功能，本文介绍如何安装 Sublime Text 插件。 打开 Sublime Text 编辑器的 Console（控制台）使用快捷键 ctrl+` 或者点击菜单 View &gt; Show Console menu 打开 Console，如图： Sublime Text 2 粘贴以下代码： 1import urllib2,os,hashlib; h = '2915d1851351e5ee549c20394736b442' + '8bc59f460fa1548d1514676163dafc88'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); os.makedirs( ipp ) if not os.path.exists(ipp) else None; urllib2.install_opener( urllib2.build_opener( urllib2.ProxyHandler()) ); by = urllib2.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); open( os.path.join( ipp, pf), 'wb' ).write(by) if dh == h else None; print('Error validating download (got %s instead of %s), please try manual install' % (dh, h) if dh != h else 'Please restart Sublime Text to finish installation') Sublime Text 3 粘贴以下代码： 1import urllib.request,os,hashlib; h = '2915d1851351e5ee549c20394736b442' + '8bc59f460fa1548d1514676163dafc88'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by) 敲回车等待安装完成后重启 Sublime Text 即可，按下快捷键 ctrl + shift + p ,输入 pci（Package Control Install 简写）如图： 敲回车即可打开插件安装界面，输入想要安装插件的名称即可开始安装，如图： Sublime Text 插件安装介绍完了，需要注意的是安装过程中要保持网络畅通。 参考网址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git 同时 push 到多个远程仓库]]></title>
      <url>http://ehlxr.me/2016/07/24/Git-%E5%90%8C%E6%97%B6-push-%E5%88%B0%E5%A4%9A%E4%B8%AA%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/</url>
      <content type="text"><![CDATA[方法一 如果一个本地仓库添加多个远程仓库，不想 git push 多次，可以修改 .git/config 文件 1vim .git/config 比如以下信息表示在 git@OSC 和 GitHub 两个远程托管 修改为以下信息 则可同时 push 到两个远程仓库 123$ git push origin masterEverything up-to-dateEverything up-to-date 方法二 添加第二个远程地址时使用以下命令： 1git remote set-url --add origin git@github.com:ehlxr/ehlxr-Hexo.git 查看远程分支 origin： 1234$ git remote -vorigin git@git.oschina.net:ehlxr/ehlxr-Hexo.git (fetch)origin git@git.oschina.net:ehlxr/ehlxr-Hexo.git (push)origin git@github.com:ehlxr/ehlxr-Hexo.git (push) 也可以同时 push 到多个远程地址 123$ git push origin masterEverything up-to-dateEverything up-to-date]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用Hexo基于GitHub Pages搭建个人博客（二）]]></title>
      <url>http://ehlxr.me/2016/07/23/%E4%BD%BF%E7%94%A8Hexo%E5%9F%BA%E4%BA%8EGitHub-Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="text"><![CDATA[上一篇介绍了 GitHub Pages 服务开启，这篇文章将介绍 Hexo 的安装和使用以及将博客部署到 GitHub Pages 的操作。 Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 一、Node.js 安装 Hexo 是基于 Node.js 安装，所以安装 Hexo 之前首先要安装 Node.js。下载地址：https://nodejs.org/en/download/ 根据自己的操作系统，下载对应版本即可。安装过程比较简单，一直下一步即可安装完成。 二、Hexo 安装 打开 Git Bash 输入以下命令开始安装 Hexo 1npm install hexo-cli -g 出现以下界面表示安装完成 三、Hexo 建站 安装 Hexo 完成后，在本地磁盘创建一个目录用于存放 Hexo 配置文件和博客源代码，我的 Hexo 存放在 D:/ehlxr 目录下。 分别执行下列命令，Hexo 将会在 D:/ehlxr/Hexo 新建所需要的文件 1234567891011# 进入 D:/ehlxr 目录cd /d/ehlxr/# 初始化所需要的文件到 Hexo 文件夹hexo init Hexo# 进入 Hexo 文件夹cd Hexo# 安装npm install 分别执行以下命令在本地进行预览 12345# 编译生成博文hexo generate# 启动Hexo服务器hexo server 出现以下画面表示服务启动成功 打开浏览器输入 http://localhost:4000/ 便可以看到最原始的博客了 四、Hexo 部署到 GitHub Pages 更新 Hexo 安装文件夹中 _config.yml 文件，如图 更新 _config.yml 文件中的 deploy 节点，如图所示，可添加多个地址（如一个 GitHub、Coding、oschina） 分别执行以下命令即可完成部署 12345npm install hexo-deployer-git --save # 安装 hexo-deployer-githexo clean # 可简写为 hexo clhexo generate # 可简写为 hexo ghexo deploy # 可简写为 hexo d 访问 yourname.github.io 即可看到博客模板的内容，对于 Hexo 的一些详细设置可以参考Hexo官方文档 。本站使用的 Hexo 主题是 NexT，详细设置可参考Next主题官方网站。 使用以下命令就可以新建一篇博客文章 1hexo new &quot;开始blog，哈哈&quot; 打开 Hexo 目录下的 source\_posts 目录就可以看见创建的文章了，如图所示 文章是 MarkDown 格式文件（关于 Markdown 语法可参考Markdown 语法说明(简体中文版)），编辑文章后保存，可以先启动本地 Hexo Server 查看效果，然后执行部署命令就完成了博客文章的发布 Markdown 编辑器我推荐使用 小书匠 至此，使用 Hexo 基于 GitHub Pages 搭建个人博客就介绍完了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用Hexo基于GitHub Pages搭建个人博客（一）]]></title>
      <url>http://ehlxr.me/2016/07/23/%E4%BD%BF%E7%94%A8Hexo%E5%9F%BA%E4%BA%8EGitHub-Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="text"><![CDATA[GitHub Pages 是 GitHub 提供的免费开源的静态站点托管服务，利用这个服务可以搭建轻量级的博客系统，本文介绍了如何使用 Hexo 结合 GitHub Pages 服务搭建个人博客。 一、安装配置 Git 安装 Git 使用 GitHub 首先要安装 Git，可根据操作系统下载不同版本的Git，Windows下载地址：https://git-scm.com/download/win 安装过程比较简单，选择默认选项配置即可下一步，不再叙述。 配置 Git 设置本地机器默认 commit 的昵称与 Email，姓名与 Email 只用于日志标识，实际推送到远程仓库时，要用有操作权限的账号登录。 12git config --global user.name &quot;ehlxr&quot; git config --global user.email &quot;ehlxr@qq.com&quot; 二、生成 SSH keys SSH Keys 是 GitHub 推荐的公钥、秘钥形式验证用户合法性的机制，添加 SSH Keys 可以省去每次都要输入密码的步骤，下面将演示如何在本地计算机生成 SSH Keys 的公钥、秘钥。 首先打开安装的 Git Bash 输入以下命令：（替换 &quot;your_email@example.com&quot; 为注册时候的邮箱） 1ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot; 当出现以下提示时，直接敲回车键选择默认地址即可（保存私钥文件位置，默认保存在当前用户文件夹下的 .ssh 文件夹中，文件名称为 id_rsa ） 1Enter file in which to save the key (/c/Users/lt/.ssh/id_rsa): 如果已经存在会提示，输入：y 敲回车替换即可 12/c/Users/lt/.ssh/id_rsa already exists.Overwrite (y/n)? 出现以下提示设置密码提示，不用设置密码，敲回车键即可 1Enter passphrase (empty for no passphrase): 再次确认密码提示，不用设密码敲回车即可 1Enter same passphrase again: 出现以下提示，表明已经成功生成了 SSH Keys 12345678910111213141516Your identification has been saved in /c/Users/lt/.ssh/id_rsa.Your public key has been saved in /c/Users/lt/.ssh/id_rsa.pub.The key fingerprint is:SHA256:dBtq6OOJs1JQat630kGqh420Y0JSb7smaR6c9jjo7h0 your_email@example.comThe key&apos;s randomart image is:+---[RSA 4096]----+| || . || o . o || = .o o o || + + o. S . ||.oo.*.o. ||oo=E +oo ||o.#+Oooo ||+OoO==o |+----[SHA256]-----+ Github 官网 SSH Keys 生成教程 三、开启 GitHub Pages 服务 GitHub 账户注册比较简单，注册免费使用的账户就可以了，这里就不细说了，需要注意的是尽量不要使用 126/163 邮箱注册，我在测试的时候收不到验证码，等收到验证码的时候已经第二天了，早就过期了，我使用 Gmail 和 QQ 邮箱都能很快收到验证码。 1.添加生成的 SSH Keys 到 GitHub 打开生成的 SSH Keys 公钥 登录注册的 GitHub 账户，按照以下图示 1、 2、 3、 4、 5、6、 7 步骤操作，复制公钥内容粘贴到下图步骤 5 的 Key 输入框中，在步骤6输入一个标题，点击步骤 7 Add SSH key，这时候会提示你输入 GitHub 密码，输入密码确认即可添加成功。 2.创建 GitHub 仓库 按照下图所示操作，仓库名称按照：yourname.github.io 格式创建，这样就可以通过 yourname.github.io 方式访问你的博客。如果创建名称为：myblog ,则博客的访问路径为 yourname.github.io/myblog 填写完仓库名称，其他选项默认，点击 Create repository 即可完成创建。 3.测试 GitHub Pages 服务 接下来在仓库根目录下创建一个 index.html 文件测试 GitHub Pages 服务是否开启成功。打开刚才创建的仓库，因为我们之前已经添加了 SSH Keys，所以选择复制如下图所示的 SSH 仓库连接 在电脑磁盘创建一个文件夹（我创建在：D:/lxr）在 Git Bash 分别输入以下两条命令 123cd /d/lxr/ # 进入创建的文件夹git init # 初始化本地仓库 在本地文件夹中创建 index.html 文件，随便输入一些内容即可，命令如下 1echo &quot;&lt;h1&gt;Hello World&lt;/h1&gt;&quot; &gt;&gt; index.html # 创建 index.html 文件 然后分别执行以下命令 1234git add index.html # 添加文件git commit -m &quot;create index.html&quot; # 提交文件git remote add origin git@github.com:ehlxr/ehlxr.github.io.git # 添加 GitHub 仓库地址，注意地址填写自己注册的 GitHub 仓库地址git push -u origin master # push 到 GitHub 浏览器访问：yourname.github.io 如果出现 index.html 输入的内容，即 GitHub Pages 服务开启成功]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[转]JMS基本概念]]></title>
      <url>http://ehlxr.me/2016/07/21/%E8%BD%AC-JMS%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      <content type="text"><![CDATA[JMS（JAVA Message Service,java消息服务）API是一个消息服务的标准或者说是规范，允许应用程序组件基于JavaEE平台创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。 基本概念JMS是java的消息服务，JMS的客户端之间可以通过JMS服务进行异步的消息传输。 消息模型 Point-to-Point(P2P) Publish/Subscribe(Pub/Sub) 即点对点和发布订阅模型 P2P模型P2P模式图 涉及到的概念 消息队列（Queue） 发送者(Sender) 接收者(Receiver) 每个消息都被发送到一个特定的队列，接收者从队列中获取消息。队列保留着消息，直到他们被消费或超时。 P2P模型的特点 每个消息只有一个消费者（Consumer）(即一旦被消费，消息就不再在消息队列中) 发送者和接收者之间在时间上没有依赖性，也就是说当发送者发送了消息之后，不管接收者有没有正在运行，它不会影响到消息被发送到队列 接收者在成功接收消息之后需向队列应答成功 如果你希望发送的每个消息都应该被成功处理的话，那么你需要P2P模式。 Pub/Sub模型Pub/Sub模式图 涉及到的概念 主题（Topic） 发布者（Publisher） 订阅者（Subscriber） 客户端将消息发送到主题。多个发布者将消息发送到Topic,系统将这些消息传递给多个订阅者。 Pub/Sub模型的特点 每个消息可以有多个消费者 发布者和订阅者之间有时间上的依赖性。针对某个主题（Topic）的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息，而且为了消费消息，订阅者必须保持运行的状态。 为了缓和这样严格的时间相关性，JMS允许订阅者创建一个可持久化的订阅。这样，即使订阅者没有被激活（运行），它也能接收到发布者的消息。 如果你希望发送的消息可以不被做任何处理、或者被一个消息者处理、或者可以被多个消费者处理的话，那么可以采用Pub/Sub模型。 消息的消费在JMS中，消息的产生和消息是异步的。对于消费来说，JMS的消息者可以通过两种方式来消费消息。 同步订阅者或接收者调用receive方法来接收消息，receive方法在能够接收到消息之前（或超时之前）将一直阻塞 异步订阅者或接收者可以注册为一个消息监听器。当消息到达之后，系统自动调用监听器的onMessage方法 JMS编程模型 ConnectionFactory 创建Connection对象的工厂，针对两种不同的jms消息模型，分别有QueueConnectionFactory和TopicConnectionFactory两种。可以通过JNDI来查找ConnectionFactory对象。 Destination Destination的意思是消息生产者的消息发送目标或者说消息消费者的消息来源。对于消息生产者来说，它的Destination是某个队列（Queue）或某个主题（Topic）;对于消息消费者来说，它的Destination也是某个队列或主题（即消息来源）。 所以，Destination实际上就是两种类型的对象：Queue、Topic可以通过JNDI来查找Destination。 Connection Connection表示在客户端和JMS系统之间建立的链接（对TCP/IP socket的包装）。Connection可以产生一个或多个Session。跟ConnectionFactory一样，Connection也有两种类型：QueueConnection和TopicConnection。 Session Session是我们操作消息的接口。可以通过session创建生产者、消费者、消息等。Session提供了事务的功能。当我们需要使用session发送/接收多个消息时，可以将这些发送/接收动作放到一个事务中。同样，也分QueueSession和TopicSession。 消息的生产者 消息生产者由Session创建，并用于将消息发送到Destination。同样，消息生产者分两种类型：QueueSender和TopicPublisher。可以调用消息生产者的方法（send或publish方法）发送消息。 消息消费者 消息消费者由Session创建，用于接收被发送到Destination的消息。两种类型：QueueReceiver和TopicSubscriber。可分别通过session的createReceiver(Queue)或createSubscriber(Topic)来创建。当然，也可以session的creatDurableSubscriber方法来创建持久化的订阅者。 MessageListener 消息监听器。如果注册了消息监听器，一旦消息到达，将自动调用监听器的onMessage方法。EJB中的MDB（Message-Driven Bean）就是一种MessageListener。 企业消息系统的好处我们先来看看下图，应用程序A将Message发送到服务器上，然后应用程序B从服务器中接收A发来的消息，通过这个图我们一起来分析一下JMS的好处： 提供消息灵活性 松散耦合 异步性 原文地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java List与数组之间的转换]]></title>
      <url>http://ehlxr.me/2016/07/20/Java-List%E4%B8%8E%E6%95%B0%E7%BB%84%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/</url>
      <content type="text"><![CDATA[1. 数组转换为List12String[] arr = new String[] &#123;"str1", "str2"&#125;;List&lt;String&gt; list = Arrays.asList(arr); 2 .List转换为数组12345List&lt;String&gt; list = new ArrayList&lt;String&gt;();list.add("str1");list.add("str2");int size = list.size();String[] arr = list.toArray(new String[size]);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MySQL日期函数]]></title>
      <url>http://ehlxr.me/2016/07/20/MySQL%E6%97%A5%E6%9C%9F%E5%87%BD%E6%95%B0/</url>
      <content type="text"><![CDATA[1. 取得当天：123456mysql&gt; SELECT curdate();+------------+| curdate() |+------------+| 2013-07-29 |+------------+ 2. 取得当前日期：123456789101112131415mysql&gt; select sysdate();+---------------------+| sysdate() |+---------------------+| 2016-05-30 13:58:17 |+---------------------+1 row in setmysql&gt; select now();+---------------------+| now() |+---------------------+| 2016-05-30 13:58:29 |+---------------------+1 row in set 3. 取得当前时间：1234567mysql&gt; select curtime();+-----------+| curtime() |+-----------+| 13:54:31 |+-----------+1 row in set 4. 取得前一天：123456mysql&gt; select date_sub(curdate(),interval 1 day);+------------------------------------+| date_sub(curdate(),interval 1 day) |+------------------------------------+| 2013-07-28 |+------------------------------------+ 5. 取得下一天：1234567mysql&gt; SELECT DATE_ADD(NOW(),INTERVAL 1 DAY);+--------------------------------+| DATE_ADD(NOW(),INTERVAL 1 DAY) |+--------------------------------+| 2016-05-31 14:09:16 |+--------------------------------+1 row in set 括号中为当天时间的前一天，如果统计前几天就将括号中的’1’改成相应的天数。如果要算月或年，直接将day改为month或year即可 6.取得前一天的年份：123456mysql&gt; SELECT YEAR(DATE_SUB(CURDATE(),INTERVAL 1 DAY));+------------------------------------------+| YEAR(DATE_SUB(CURDATE(),INTERVAL 1 DAY)) |+------------------------------------------+| 2013 |+------------------------------------------+ 7.SYSDATE()为：2016-05-30 周一123456SELECT WEEK(SYSDATE()); -- 22SELECT WEEKOFYEAR(SYSDATE()); -- 22SELECT WEEKDAY(SYSDATE()); -- 0SELECT DAY(SYSDATE()); -- 30SELECT MONTH(SYSDATE()); -- 5SELECT YEAR(SYSDATE()); -- 2016 8.date_sub()函数的例子：今天是2013年5月20日 12345678910date_sub('2012-05-25', INTERVAL 1 DAY) -- 表示 2012-05-24date_sub('2012-05-25', INTERVAL 0 DAY) -- 表示 2012-05-25date_sub('2012-05-25', INTERVAL - 1 DAY) -- 表示 2012-05-26date_sub('2012-05-31', INTERVAL - 1 DAY) -- 表示 2012-06-01date_sub(curdate(), INTERVAL 1 DAY) -- 表示 2013-05-19date_sub(curdate(), INTERVAL - 1 DAY) -- 表示 2013-05-21date_sub(curdate(), INTERVAL 1 MONTH) -- 表示 2013-04-20date_sub(curdate(), INTERVAL - 1 MONTH) -- 表示 2013-06-20date_sub(curdate(), INTERVAL 1 YEAR) -- 表示 2012-05-20date_sub(curdate(), INTERVAL - 1 YEAR) -- 表示 2014-05-20]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[开始blog，哈哈]]></title>
      <url>http://ehlxr.me/2016/07/19/%E5%BC%80%E5%A7%8Bblog%EF%BC%8C%E5%93%88%E5%93%88/</url>
      <content type="text"><![CDATA[123public static void main(String args[])&#123; System.out.println("hello world");&#125;]]></content>
    </entry>

    
  
  
</search>
